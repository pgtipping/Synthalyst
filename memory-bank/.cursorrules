# Project Intelligence - [2025-03-11 15:06:15]

## Core Development Patterns

### Project Structure and Configuration - [2025-03-11 15:06:15]

- Development folder: `/nextjs-app`
- Git directory: root folder `/synthalyst`
- Project guides: `/guides`
- Development server runs on port 3001
- All development must be focused in the `/nextjs-app` directory
- Never install packages in the root folder
- Always check folder before installing any package
- Update memory bank before staging files
- Stage and commit files from the root directory
- Always stage files with `git add .`

### Next.js App Router Conventions - [2025-03-11 15:06:15]

- Each route requires its own directory (e.g., `/about`, `/services`, `/contact`)
- The actual page component must be named `page.tsx` inside that directory
- Example structure:
  ```
  src/app/
  ├── about/
  │   └── page.tsx
  ├── services/
  │   └── page.tsx
  ├── contact/
  │   └── page.tsx
  ```
- Do not use flat files like `about.tsx` directly in the app directory
- Layouts can be defined using `layout.tsx` files in the appropriate directories
- Route groups can be created using parentheses in directory names: `(auth)/login`
- Dynamic routes use square brackets: `[slug]/page.tsx`
- Catch-all routes use triple dots: `[...slug]/page.tsx`
- Optional catch-all routes use double square brackets: `[[...slug]]/page.tsx`

### Client vs Server Components - [2025-03-11 15:06:15]

- All components are Server Components by default
- Add "use client" directive at the top of the file to make it a Client Component
- Client Components are needed for:
  - Interactive features (forms, buttons, etc.)
  - Browser APIs (localStorage, navigator, etc.)
  - React hooks (useState, useEffect, etc.)
  - Event handlers (onClick, onError, etc.)
- Server Components are better for:
  - Fetching data
  - Accessing backend resources directly
  - Keeping sensitive information on the server
  - Reducing client-side JavaScript

### Event Handlers in Server Components - [2025-03-11 15:06:15]

- Event handlers cannot be passed to Client Component props from Server Components
- Error: "Event handlers cannot be passed to Client Component props"
- Common event handlers that require Client Components:
  - onClick
  - onChange
  - onSubmit
  - onError
  - onLoad
  - onFocus
  - onBlur
- Solutions:
  1. Convert the component to a Client Component by adding "use client" directive
  2. Move the event handler to a separate Client Component
  3. Use a different approach that doesn't require event handlers

### ClientComponentWrapper Pattern - [2025-03-11 15:06:15]

- Use the ClientComponentWrapper for client components that use Next.js navigation hooks
- Provides a consistent Suspense boundary for client components
- Implements a standardized loading UI with spinner and customizable text
- Simplifies the implementation of proper Suspense boundaries
- Available variants:
  - Default: Centered spinner with text
  - Minimal: Inline spinner with small text
  - Fullscreen: Overlay with backdrop blur
  - Skeleton: Content placeholder
- Higher-Order Component (HOC) version available for a more functional approach
- Use for any client component that uses:
  - useSearchParams()
  - usePathname()
  - useRouter()

### Next.js 15 Type Requirements - [2025-03-11 15:06:15]

- In Next.js 15, route handlers and page components with dynamic route parameters must have specific type requirements:
- Route Handler Parameters:
  ```typescript
  export async function GET(
    req: Request,
    { params }: { params: Promise<{ id: string }> }
  ) {
    const { id } = await params;
    // Use id here
  }
  ```
- Page Component Parameters:

  ```typescript
  interface PageProps {
    params: Promise<{ id: string }>;
  }

  export default async function Page(props: PageProps) {
    const params = await props.params;
    const { id } = params;
    // Use id here
  }
  ```

- Always await the params object before accessing its properties
- When working with LLM responses, always add null checks to prevent potential null reference errors:
  ```typescript
  const responseContent = completion.choices[0].message.content as string;
  const generatedContent = JSON.parse(responseContent || "{}");
  ```

## UI and Component Patterns

### Component Architecture - [2025-03-11 15:06:15]

- The application uses a component-based architecture with shadcn UI components as the foundation
- All shadcn UI components are located in `@/components/ui/`
- Components follow a consistent pattern with proper TypeScript typing
- Tailwind animations and keyframes are centralized in the tailwind.config.ts file with no duplications
- Component organization:
  - **Feature-specific Components**: Located in `src/app/[feature]/components/`
  - **Shared Components**: Located in `src/components/`
    - `ui/`: Basic UI components (buttons, inputs, etc.)
    - `layout/`: Layout components (Header, Footer, etc.)
    - `shared/`: Other shared components used across features
  - **Import Pattern**:
    - Use `@/` path alias for imports from src directory
    - Example: `import { Button } from "@/components/ui/button"`
    - Feature-specific imports use relative paths

### Toast System - [2025-03-11 15:06:15]

- The project uses the sonner toast system
- Always import toast from `@/lib/toast-migration` instead of `@/hooks/use-toast`
- Example usage:

  ```typescript
  import { toast } from "@/lib/toast-migration";

  // Success toast
  toast({
    title: "Success",
    description: "Operation completed successfully.",
  });

  // Error toast
  toast({
    variant: "destructive",
    title: "Error",
    description: "Something went wrong.",
  });
  ```

- The main Toaster component is imported from our custom UI component:
  - `import { Toaster } from "@/components/ui/sonner";`
  - This is ONLY used in the root layout.tsx file
  - DO NOT add Toaster components to individual pages

### TooltipProvider Usage Pattern - [2025-03-11 15:06:15]

- Always wrap components that use tooltips with a TooltipProvider
- Prefer wrapping the entire component with a single TooltipProvider at the top level
- Avoid nesting TooltipProviders as this can cause CSS issues and UI breakage
- When using tooltips in a component, ensure the following structure:
  ```tsx
  <TooltipProvider>
    <Tooltip>
      <TooltipTrigger>
        <InfoIcon className="h-4 w-4 ml-1 text-gray-400" />
      </TooltipTrigger>
      <TooltipContent>
        <p className="max-w-xs">Tooltip content here</p>
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
  ```
- If you have multiple tooltips in a component, wrap the entire component with a single TooltipProvider

### Component Variants - [2025-03-11 15:06:15]

- The Card component has been extended with a gradient variant:
  ```tsx
  <Card variant="gradient" variantKey="primary">
    <CardHeader>
      <CardTitle>Card Title</CardTitle>
    </CardHeader>
    <CardContent>
      <p>Card content</p>
    </CardContent>
  </Card>
  ```
- Available gradient keys:
  - `primary`: Blue to indigo gradient
  - `secondary`: Purple to pink gradient
  - `accent`: Amber gradient
  - `info`: Subtle blue gradient
  - `default`: Subtle gray gradient

### UI Animation Guidelines - [2025-03-11 15:06:15]

- Animations should be subtle and professional, not flashy or distracting
- Use longer intervals (3+ seconds) between animation changes
- Choose color schemes that align with the brand identity (blues, blacks)
- Implement proper cleanup to prevent memory leaks
- Use React's useId() hook for stable IDs in SVG elements
- Add aria-labels to animated elements for accessibility
- Test animations on both high and low-end devices to ensure performance

### Responsive Design Patterns - [2025-03-11 15:06:15]

- Start with a minimal, functional mobile design
- Add features and complexity for larger screens
- Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) to control visibility
- Hide descriptive text on small screens with `hidden md:inline-block`
- Show only essential icons/badges on mobile
- Maintain touch-friendly tap targets (min 44px) on all screen sizes
- Use flex-wrap for horizontal elements that might overflow
- Implement grid layouts with auto-fit/auto-fill for dynamic columns
- Set appropriate min/max widths to prevent extreme scaling
- Use responsive spacing utilities (p-2 sm:p-4 md:p-6)
- Maintain adequate whitespace on all screen sizes
- Reduce padding/margins proportionally on smaller screens
- Test at standard breakpoints: 640px, 768px, 1024px, 1280px

## LLM Integration Patterns

### AI Excellence Focus - [2025-03-11 15:06:15]

- The primary goal of all development is to make LLMs and AI agents shine in user interactions
- Every feature should be designed to showcase the intelligence of the AI
- Prioritize quality of AI outputs over quantity of features
- Key principles to follow:
  1. Craft sophisticated prompts that bring out the best in LLMs
  2. Implement post-processing to ensure professional formatting of AI outputs
  3. Design features that maintain context between user interactions
  4. Personalize AI responses based on user needs and preferences
  5. Continuously refine AI implementations based on user feedback

### LLM Implementation Best Practices - [2025-03-11 15:06:15]

- Always use the most appropriate model for each task:
  - Use Gemini 2.0 Flash for quick, responsive interactions
  - Use GPT-4 for complex reasoning and creative tasks
  - Use specialized models for specific domains when appropriate
- Implement robust error handling for AI interactions:
  - Gracefully handle API failures
  - Provide meaningful fallbacks when AI services are unavailable
  - Implement retry logic with exponential backoff
- Optimize prompts for each model's strengths and limitations
- Test AI outputs extensively with diverse inputs
- Monitor and log AI performance metrics to identify areas for improvement
- Regularly review and update prompts based on output quality

### Gemini Model Usage Pattern - [2025-03-11 15:06:15]

- Always use the centralized `getGeminiModel()` function from `nextjs-app/src/lib/gemini.ts` to access the Gemini model
- Never hardcode the model name in individual components or API routes
- The current model version is "gemini-2.0-flash-001"
- Environment variable: `GEMINI_API_KEY` (server-side only)
- Example usage:

  ```typescript
  import { getGeminiModel } from "@/lib/gemini";

  const generateContent = async (prompt: string) => {
    try {
      const model = getGeminiModel();
      const result = await model.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error("Error generating content with Gemini:", error);
      throw error;
    }
  };
  ```

### OpenRouter API Integration - [2025-03-11 15:06:15]

- The OpenRouter API is used for accessing the Llama 3.2 3b model in the Training Plan Creator
- Always use the `openRouter` instance from `@/lib/openrouter` for OpenRouter API calls
- The model name is "meta-llama/llama-3.2-3b-instruct"
- Environment variable: `OPENROUTER_API_KEY`
- Implementation in `nextjs-app/src/lib/openrouter.ts` and `nextjs-app/src/lib/llama.ts`
- Example usage:

  ```typescript
  import { openRouter } from "@/lib/openrouter";

  // Call OpenRouter with Llama 3.2 3b
  const response = await openRouter.chat.completions.create({
    model: "meta-llama/llama-3.2-3b-instruct",
    messages: [
      { role: "system", content: systemMessage },
      { role: "user", content: prompt },
    ],
    temperature: 0.7,
    max_tokens: 3500,
  });
  ```

### Two-Stage LLM Approach - [2025-03-11 15:06:15]

- The Training Plan Creator uses a two-stage approach for premium users:
  1. Gemini 2.0 Flash for resource recommendations
  2. Llama 3.2 3b for plan generation
- For free users, only the Llama 3.2 3b model is used with an enhanced prompt
- This approach ensures premium users get high-quality, current resources while maintaining good plan generation for all users
- Implementation in `nextjs-app/src/app/api/training-plan/enhanced-generate/route.ts`

### Structured Text Response Pattern - [2025-03-11 15:06:15]

- When working with LLM responses that need to be parsed into structured data, prefer using clear section headers over JSON
- Benefits of section-based extraction:
  - More reliable parsing with less complex code
  - Easier to debug and maintain
  - Less prone to JSON formatting errors from the LLM
  - Simpler extraction logic
- Implementation pattern:
  1. In the prompt, specify exact section headers (e.g., "QUESTIONS:", "EVALUATION TIPS:")
  2. Request numbered items within each section for easier parsing
  3. Use regex to extract content between section headers
  4. Process each section's content separately
- Example prompt structure:

  ```
  Format your response as follows:

  SECTION_1:
  1. First item
  2. Second item
  ...

  SECTION_2:
  1. First item
  2. Second item
  ...
  ```

- Always include fallback mechanisms for when the LLM doesn't follow the format exactly
- For HTML content, use simple text-to-HTML conversion rather than asking the LLM to generate HTML directly

### LLM Quality Control Patterns - [2025-03-11 15:06:15]

- When implementing LLM-based features, always include comprehensive quality control measures:
  1. **Enhanced Prompting**:
     - Use detailed system prompts with specific instructions
     - Include examples of desired output format and quality
     - Specify requirements for structure, completeness, and relevance
  2. **Parameter Tuning**:
     - Use lower temperature (0.5-0.7) for more consistent outputs
     - Adjust max_tokens based on the expected response length
     - Consider using top_p and frequency_penalty for diverse but controlled outputs
  3. **Output Validation**:
     - Implement comprehensive quality checks for LLM outputs
     - Validate minimum length, structure, and completeness
     - Check for presence of key terms relevant to the domain
     - Ensure proper sentence structure and punctuation
  4. **Fallback Mechanisms**:
     - Create high-quality fallback content for when LLM generation fails
     - Make fallbacks context-aware using user input parameters
     - Ensure fallbacks maintain the same structure and format as expected LLM outputs
  5. **Model Selection**:
     - Use smaller, more reliable models when possible
     - Implement model fallback chains (e.g., Llama → Gemini)
     - Balance performance with reliability based on the use case

### Feedback Collection Patterns - [2025-03-11 15:06:15]

- Every AI-powered tool should include at least one feedback mechanism
- Types of feedback mechanisms to implement:
  - Simple rating systems (1-5 stars, thumbs up/down)
  - Detailed feedback forms for specific aspects of AI output
  - In-context feedback options during tool usage
  - Follow-up emails requesting feedback after tool usage
- Best practices for feedback implementation:
  - Keep primary feedback mechanisms simple and non-intrusive
  - Offer more detailed feedback options as a secondary step
  - Clearly explain how feedback improves the AI
  - Thank users for providing feedback
  - Show appreciation for detailed feedback

## Testing Patterns

### Component Test Structure - [2025-03-11 15:06:15]

```typescript
// Always follow this structure for component tests
describe("ComponentName", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset any global mocks
  });

  it("renders required elements", () => {
    // Test basic rendering
  });

  it("handles user interactions", async () => {
    // Test user interactions
  });

  it("handles API interactions", async () => {
    // Test API calls
  });

  it("handles error cases", async () => {
    // Test error scenarios
  });
});
```

### Mock Component Patterns - [2025-03-11 15:06:15]

```typescript
// Pattern for mocking form components
jest.mock("@/components/ui/form", () => ({
  Form: ({ children }) => <div>{children}</div>,
  FormField: ({ render, name }) =>
    render({
      field: { value: "", onChange: jest.fn(), name },
    }),
  // ... other form components
}));

// Pattern for mocking select components
jest.mock("@/components/ui/select", () => ({
  Select: ({ children, name, ...props }) => (
    <select role="combobox" aria-label={name} title={name} {...props}>
      {children}
    </select>
  ),
  // ... other select components
}));
```

### API Test Structure - [2025-03-11 15:06:15]

1. Test successful API calls:
   - Mock successful responses
   - Verify response status and body
   - Verify API was called with correct parameters
2. Test validation errors:
   - Test with invalid or missing parameters
   - Verify 400 status code
   - Verify error messages
3. Test API errors:
   - Mock API failures
   - Verify proper error handling
   - Verify 500 status code
4. Test edge cases:
   - Empty responses
   - Malformed responses
   - Missing API keys

### Mock Prisma Client Pattern - [2025-03-11 15:06:15]

The project uses a standardized approach for mocking the Prisma client in API tests. This pattern is implemented in `nextjs-app/src/lib/test/prisma-mock.ts` and should be followed for all API tests.

Key components:

1. **TypeScript Interfaces**: Define interfaces for all mock storage objects to ensure type safety.
2. **Mock Implementation**: Create a mock implementation that mimics the Prisma client's behavior.
3. **Error Handling**: Implement consistent error handling across all mock methods.
4. **Test Setup**: Use the mock in tests by accessing the global mock instance.
5. **Creating Test Data**: Create test data using the mock Prisma client.
6. **Handling Relationships**: For many-to-many relationships, directly update the storage.
7. **API Route Params**: When testing API routes, use the correct pattern for params.
8. **Verifying Results**: Verify the results of API calls.

## Form Patterns

### Form Implementation - [2025-03-11 15:06:15]

1. Use React Hook Form for form state management
2. Use Zod for schema validation
3. Use Radix UI components for accessibility
4. Use toast notifications for feedback

### Form Validation - [2025-03-11 15:06:15]

1. Required fields:
   - Minimum length validation
   - Custom error messages
2. Optional fields:
   - Clear validation rules
   - Default values
3. Select fields:
   - Predefined options
   - Default selection

### Form Submission - [2025-03-11 15:06:15]

1. Loading state management
2. Error handling
3. Success feedback
4. Form reset
5. Data transformation

### Form Field Structure - [2025-03-11 15:06:15]

```typescript
<FormField
  control={form.control}
  name="fieldName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Label</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormDescription>Helper text</FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Error Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  // API call
  const response = await fetch("/api/endpoint");
  if (!response.ok) {
    throw new Error("API Error");
  }
  // Success handling
  toast({
    title: "Success",
    description: "Operation completed successfully",
  });
} catch (error) {
  // Error handling
  toast({
    title: "Error",
    description: "Operation failed. Please try again.",
    variant: "destructive",
  });
}
```

### API Response Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  const response = await fetch("/api/endpoint", {
    method: "METHOD",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  });

  // Parse the response data first
  let data;
  try {
    data = await response.json();
  } catch (parseError) {
    console.error("Error parsing response:", parseError);
    data = { fallbackData: true };
  }

  // Then check if the response is OK
  if (!response.ok) {
    throw new Error(data.error || "Default error message");
  }

  // Use the parsed data
  return data;
} catch (error) {
  console.error("Error:", error);
  // Handle the error appropriately
}
```

## Authentication and Authorization

### Authentication System - [2025-03-11 15:06:15]

- The application uses NextAuth.js for authentication with the following features:
  - Credentials provider (email/password)
  - Google OAuth provider
- Configuration in `nextjs-app/src/app/api/auth/[...nextauth]/auth.ts`
- Environment variables:
  ```
  NEXTAUTH_URL=http://localhost:3000
  NEXTAUTH_SECRET=your-secret-here
  GOOGLE_CLIENT_ID=your-google-client-id
  GOOGLE_CLIENT_SECRET=your-google-client-secret
  ```
- Authentication pages:
  - Sign-in page: `nextjs-app/src/app/auth/signin/page.tsx`
  - Sign-up page: `nextjs-app/src/app/auth/signup/page.tsx`
- Session management:
  - JWT strategy for session tokens
  - Session data stored in cookies
  - Session expiration configurable in NextAuth options

### Role-Based Access Control - [2025-03-11 15:06:15]

- Three-tier role system:
  - Superadmin (pgtipping1@gmail.com)
  - Admin
  - User
- Role hierarchy enforced through multiple layers:
  - API route authorization
  - Client-side component protection
  - Server-side session validation
- Role checks in API routes with proper error handling
- Protected routes with client-side redirects
- Real-time role updates with optimistic UI
- Exclusive superadmin privileges for role modification
- Protected superadmin account from role changes
- Role update API with proper validation
- Real-time UI feedback for role changes

## Feature-Specific Patterns

### Blog Post Creation Pattern - [2025-03-11 15:06:15]

- Blog posts can be created through two methods:
  1. Direct API method (Preferred):
     - Use `/api/posts` endpoint for database-driven posts
     - Use `/api/blog/generate` for LLM-assisted content creation
     - No filesystem operations required
     - Works consistently across all environments
  2. MDX file method (Legacy/Optional):
     - Store MDX files in filesystem
     - Requires manual file syncing across environments
     - More complex to maintain
     - Can cause deployment issues
- Key principles to follow:
  1. Prefer direct API method for new blog posts
  2. Use LLM assistance for professional content generation
  3. Store all content in database for consistency
  4. Avoid filesystem-based content when possible

### Blog Post Layout Pattern - [2025-03-11 15:06:15]

- Blog post content should use a constrained width to improve readability:
  ```jsx
  <article className="prose prose-lg max-w-4xl mx-auto">
    {/* Blog post content */}
  </article>
  ```
- Use black text for paragraph content to ensure readability
- Use Radix UI icons for a professional and consistent look
- Key aspects of this pattern:
  - Use `max-w-4xl` for blog post content to match comment section width
  - Avoid using `max-w-none` which would override parent width constraints
  - Center content with `mx-auto` for balanced white space on both sides
  - Maintain consistent width between article content and comments section
  - This width provides optimal readability while adding sufficient white space

### JD Developer Form Validation - [2025-03-11 15:06:15]

- The JD Developer form has been updated to make education, experience, and certifications optional. The only mandatory fields for generating job descriptions are:
  - Job title
  - Employment type
  - Position level
  - Industry
- The API validation schema in `nextjs-app/src/app/api/jd-developer/generate/route.ts` has been modified to make these fields optional by using `.default([])` instead of `.min(1, "...")`.
- The POST function has also been updated to ensure that all arrays are properly passed to the `generateJobDescription` function, even if they're not provided in the request.
- The UI already correctly labels these fields as optional:
  - Educational Requirements (Optional)
  - Professional Experience (Optional)
  - Required Certifications (Optional)

### Template Filtering Pattern - [2025-03-11 15:06:15]

- Templates are stored in the same database table as regular job descriptions
- Templates are identified by the `isTemplate` flag in the metadata
- Two-layer filtering approach is used to ensure proper separation:
  1. Database query filtering: `content: { not: { contains: '"isTemplate":true' } }`
  2. Parsed content verification: `if (parsedContent.metadata?.isTemplate === true) { return null; }`
- This double-checking approach ensures templates only appear in the templates list
- Always filter out null entries after parsing: `.filter(Boolean)`
- Handle JSON parsing errors gracefully with try/catch blocks
- Log parsing errors for debugging: `console.error(`Error parsing JD ${jd.id}:`, error);`

### Newsletter System Patterns - [2025-03-11 15:06:15]

- All newsletter routes must be under `/api/admin/newsletter/`
- All routes require admin role authentication
- Use Prisma's type-safe query builder
- Implement comprehensive error handling
- Return consistent response formats
- Database Models:
  - NewsletterSubscriber: Manages subscriber data and status
  - NewsletterTemplate: Stores reusable email templates
  - NewsletterSend: Tracks newsletter sending history
  - NewsletterReply: Handles subscriber responses
- Field Naming Conventions:
  - Use `createdAt` for creation timestamps
  - Use `updatedAt` for modification timestamps
  - Use descriptive names for status fields
  - Maintain consistent field names across models

## Development Workflow

### Command Execution Safety - [2025-03-11 15:06:15]

1. ALWAYS verify current directory before running any commands
2. Use `list_dir` to check directory structure
3. Navigate to correct directory if needed
4. Verify package.json exists in current directory before running npm commands
5. Document directory context in explanations
6. ALWAYS add a space before ALL terminal commands to ensure proper history tracking and prevent typo errors
   - Example: ` ls -la` instead of `ls -la`
   - Example: ` git status` instead of `git status`
   - Example: ` cd src` instead of `cd src`
   - This applies to all commands: ` npm`, ` git`, ` ls`, ` cd`, etc.

### Git Commit Approach - [2025-03-11 15:06:15]

- When committing changes to the repository, always use `git add .` instead of specifying individual file paths
- The correct approach for committing changes is:

  ```bash
  # Stage all changes
  git add .

  # Commit with a descriptive message
  git commit -m "Descriptive message about the changes"
  ```

- Git Commit Messages:
  - feat: New features
  - fix: Bug fixes
  - test: Test changes
  - docs: Documentation
  - refactor: Code improvements
  - style: Formatting changes

### Memory Bank Update Pattern - [2025-03-11 15:06:15]

- ALWAYS programmatically determine today's date when updating memory bank files
- Never use hardcoded dates in memory bank entries
- Use the following pattern to get the current date in YYYY-MM-DD format:
  ```bash
  # In terminal
  date +"%Y-%m-%d"
  ```
  ```javascript
  // In JavaScript
  const today = new Date().toISOString().split("T")[0];
  ```
- Apply the current date to all new entries in memory bank files:
  - Use the date for section headings: `## Current Focus (YYYY-MM-DD)`
  - Use the date for entry timestamps: `- ✅ UPDATED: Feature X (YYYY-MM-DD)`
  - Use the date for file headings: `# Progress Report - YYYY-MM-DD`

### Environment Configuration Pattern - [2025-03-11 15:06:15]

- Local Development:
  - `.env` file contains development configuration
  - Variables are commented with explanations
  - Duplicate entries are avoided
- Production:
  - Production values should be set in the deployment platform (Vercel)
  - Alternative: use `.env.production` for production values
  - Comments indicate which values to use in production
- Critical Variables:
  - `NEXTAUTH_URL`: The base URL of the application
  - `NEXTAUTH_SECRET`: Secret for NextAuth session encryption
  - `DATABASE_URL`: Connection string for the database
  - `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: Google OAuth credentials
  - `GEMINI_API_KEY`: API key for Gemini LLM
  - `OPENROUTER_API_KEY`: API key for OpenRouter (Llama model)

### Sensitive Information Handling - [2025-03-11 15:06:15]

- NEVER commit .env files to the repository
- The .env file should be listed in .gitignore
- Use .env.example to document required environment variables without actual values
- If .env is accidentally committed, it must be removed from the entire git history
- GitHub has push protection that blocks commits containing secrets
- If a push is rejected due to containing secrets, you must remove the secrets from the git history
- Never use the GitHub option to allow the secret, as this is a security risk

# ApplyRight Feature Implementation - June 14, 2023

## Document Parsing Strategy - [2023-06-14]

When implementing document parsing for the ApplyRight feature, we initially encountered issues with PDF.js integration. The PDF.js library required specific configuration to work properly in a Next.js environment, particularly with its worker files.

### Initial PDF.js Integration Issues

The main issue was that the PDF.js worker file couldn't be found during the build process, resulting in the error:

```
Error: ENOENT: no such file or directory, open 'C:\Users\pgeor\OneDrive\Documents\Web Dev\synthalyst\nextjs-app\node_modules\pdfjs-dist\build\pdf.js'
```

### Solution: Client-Side Only PDF Parsing

After researching alternatives, we implemented PDF support using the react-pdftotext package with dynamic imports to ensure it only runs on the client side. This approach avoids server-side rendering issues with the PDF.js dependency.

Key benefits of this approach:

1. Avoids server-side rendering issues with PDF.js
2. Uses dynamic imports to load the PDF parser only when needed
3. Provides a clean fallback for server-side rendering
4. Works well with Next.js without complex configuration
5. Memory-safe implementation

Implementation:

```typescript
async function parsePdf(file: File): Promise<string> {
  try {
    // Dynamically import the PDF parser only when needed (client-side only)
    if (typeof window === "undefined") {
      // We're on the server, return a message
      return "PDF parsing is only available in the browser. The file will be processed when viewed in the browser.";
    }

    // We're in the browser, dynamically import the PDF parser
    const pdfToTextModule = await import("react-pdftotext");
    const pdfToText = pdfToTextModule.default;

    const text = await pdfToText(file);
    return text.trim();
  } catch (error) {
    console.error("Error parsing PDF:", error);
    throw new Error(
      "Failed to extract text from PDF. Please try a different file format."
    );
  }
}
```

## UI Component Structure (2025-03-12)

The ApplyRight feature follows a step-by-step wizard pattern with the following components:

1. **FileUpload** - Handles resume file uploads with drag-and-drop and click-to-browse functionality
2. **JobDescription** - Allows users to input job description text with a single "Continue" button
3. **Transform** - Processes the resume against the job description
4. **Results** - Displays and allows download of transformed documents

### UI Improvements

- Made the entire drop area in FileUpload component clickable, not just the button
- Removed redundant "Next" button in job description step to avoid confusion with the "Continue" button
- Ensured consistent button placement and styling throughout the wizard flow

## API Integration

The ApplyRight feature uses the Gemini API for resume transformation. The API route is implemented at `/api/apply-right/transform` and includes:

1. Request validation using Zod
2. Error handling
3. Fallback mode for when the API is unavailable

## User Experience Considerations

1. Clear feedback through toast notifications
2. Step-by-step guided process
3. Responsive design for all screen sizes
4. Comprehensive error handling

## PDF Generation Implementation - [2023-06-15]

The ApplyRight feature now includes professional PDF generation for the transformed resumes and cover letters. This implementation uses the jsPDF library to create well-formatted PDF documents with proper headers, footers, and intelligent text layout.

### Key Features

1. **Professional Document Formatting**:

   - Document headers with titles
   - Page numbers in footers
   - Intelligent paragraph detection and formatting
   - Multi-page support with proper pagination
   - Heading detection and emphasis

2. **User Experience Improvements**:

   - Clear "Download PDF" buttons
   - Descriptive text explaining the PDF download feature
   - Success notifications when PDFs are downloaded
   - Consistent document properties for better organization

3. **Technical Implementation**:
   - Uses jsPDF library for PDF generation
   - Client-side generation for immediate download
   - No server-side processing required
   - Intelligent text parsing to maintain document structure

This enhancement significantly improves the user experience by providing professionally formatted documents that are ready for immediate use in job applications.

# ApplyRight Feature UI and PDF Improvements - [2025-03-12 06:45:00]

## Resume and Cover Letter Preview Enhancement

The ApplyRight feature's UI has been significantly improved with enhanced resume and cover letter previews. Key improvements include:

1. **Intelligent Section Detection**:

   - Automatically identifies and styles different resume sections (summary, experience, education, etc.)
   - Detects and properly formats contact information
   - Recognizes and formats company/position information

2. **Enhanced Bullet Point Rendering**:

   - Proper indentation based on original formatting
   - Visual bullet points with consistent styling
   - Proper spacing and alignment

3. **Typography Improvements**:

   - Better font choices (sans-serif for resume, serif for cover letter)
   - Improved spacing and line height
   - Better text color management for readability

4. **Hydration Error Fix**:
   - Fixed HTML structure issue where a Badge component (div) was incorrectly placed inside a paragraph tag
   - Replaced p tag with properly styled div to maintain visual appearance while fixing the error

## PDF Generation Enhancement

The PDF generation for both resumes and cover letters has been significantly improved:

1. **Professional Layout**:

   - Added proper headers with candidate name and contact information
   - Improved section headers with background colors and proper spacing
   - Better page margins and content flow
   - Professional footer with page numbers

2. **Intelligent Content Processing**:

   - Automatically extracts and positions candidate name, contact info, and dates
   - Detects and properly formats section headers
   - Recognizes and formats bullet points with proper indentation
   - Identifies company/position information and applies appropriate styling

3. **Dynamic Filename Generation**:

   - Creates filenames based on candidate name when available
   - Adds appropriate file type suffix (Resume/Cover_Letter)

4. **Typography and Styling**:
   - Improved font selection and sizing
   - Better text color management for readability
   - Proper spacing between sections and paragraphs
   - Consistent styling throughout the document

These improvements significantly enhance the user experience by providing more professional-looking previews and downloads, making the ApplyRight feature more valuable to users.
