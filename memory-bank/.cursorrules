# Project Intelligence - [2025-03-11 15:06:15]

## Core Development Patterns

### Project Structure and Configuration - [2025-03-11 15:06:15]

- Development folder: `/nextjs-app`
- Git directory: root folder `/synthalyst`
- Project guides: `/guides`
- Development server runs on port 3001
- All development must be focused in the `/nextjs-app` directory
- Never install packages in the root folder
- Always check folder before installing any package
- Update memory bank before staging files
- Stage and commit files from the root directory
- Always stage files with `git add .`

### Next.js App Router Conventions - [2025-03-11 15:06:15]

- Each route requires its own directory (e.g., `/about`, `/services`, `/contact`)
- The actual page component must be named `page.tsx` inside that directory
- Example structure:
  ```
  src/app/
  ├── about/
  │   └── page.tsx
  ├── services/
  │   └── page.tsx
  ├── contact/
  │   └── page.tsx
  ```
- Do not use flat files like `about.tsx` directly in the app directory
- Layouts can be defined using `layout.tsx` files in the appropriate directories
- Route groups can be created using parentheses in directory names: `(auth)/login`
- Dynamic routes use square brackets: `[slug]/page.tsx`
- Catch-all routes use triple dots: `[...slug]/page.tsx`
- Optional catch-all routes use double square brackets: `[[...slug]]/page.tsx`

### Client vs Server Components - [2025-03-11 15:06:15]

- All components are Server Components by default
- Add "use client" directive at the top of the file to make it a Client Component
- Client Components are needed for:
  - Interactive features (forms, buttons, etc.)
  - Browser APIs (localStorage, navigator, etc.)
  - React hooks (useState, useEffect, etc.)
  - Event handlers (onClick, onError, etc.)
- Server Components are better for:
  - Fetching data
  - Accessing backend resources directly
  - Keeping sensitive information on the server
  - Reducing client-side JavaScript

### Event Handlers in Server Components - [2025-03-11 15:06:15]

- Event handlers cannot be passed to Client Component props from Server Components
- Error: "Event handlers cannot be passed to Client Component props"
- Common event handlers that require Client Components:
  - onClick
  - onChange
  - onSubmit
  - onError
  - onLoad
  - onFocus
  - onBlur
- Solutions:
  1. Convert the component to a Client Component by adding "use client" directive
  2. Move the event handler to a separate Client Component
  3. Use a different approach that doesn't require event handlers

### ClientComponentWrapper Pattern - [2025-03-11 15:06:15]

- Use the ClientComponentWrapper for client components that use Next.js navigation hooks
- Provides a consistent Suspense boundary for client components
- Implements a standardized loading UI with spinner and customizable text
- Simplifies the implementation of proper Suspense boundaries
- Available variants:
  - Default: Centered spinner with text
  - Minimal: Inline spinner with small text
  - Fullscreen: Overlay with backdrop blur
  - Skeleton: Content placeholder
- Higher-Order Component (HOC) version available for a more functional approach
- Use for any client component that uses:
  - useSearchParams()
  - usePathname()
  - useRouter()

### Next.js 15 Type Requirements - [2025-03-11 15:06:15]

- In Next.js 15, route handlers and page components with dynamic route parameters must have specific type requirements:
- Route Handler Parameters:
  ```typescript
  export async function GET(
    req: Request,
    { params }: { params: Promise<{ id: string }> }
  ) {
    const { id } = await params;
    // Use id here
  }
  ```
- Page Component Parameters:

  ```typescript
  interface PageProps {
    params: Promise<{ id: string }>;
  }

  export default async function Page(props: PageProps) {
    const params = await props.params;
    const { id } = params;
    // Use id here
  }
  ```

- Always await the params object before accessing its properties
- When working with LLM responses, always add null checks to prevent potential null reference errors:
  ```typescript
  const responseContent = completion.choices[0].message.content as string;
  const generatedContent = JSON.parse(responseContent || "{}");
  ```

## UI and Component Patterns

### Component Architecture - [2025-03-11 15:06:15]

- The application uses a component-based architecture with shadcn UI components as the foundation
- All shadcn UI components are located in `@/components/ui/`
- Components follow a consistent pattern with proper TypeScript typing
- Tailwind animations and keyframes are centralized in the tailwind.config.ts file with no duplications
- Component organization:
  - **Feature-specific Components**: Located in `src/app/[feature]/components/`
  - **Shared Components**: Located in `src/components/`
    - `ui/`: Basic UI components (buttons, inputs, etc.)
    - `layout/`: Layout components (Header, Footer, etc.)
    - `shared/`: Other shared components used across features
  - **Import Pattern**:
    - Use `@/` path alias for imports from src directory
    - Example: `import { Button } from "@/components/ui/button"`
    - Feature-specific imports use relative paths

### Toast System - [2025-03-11 15:06:15]

- The project uses the sonner toast system
- Always import toast from `@/lib/toast-migration` instead of `@/hooks/use-toast`
- Example usage:

  ```typescript
  import { toast } from "@/lib/toast-migration";

  // Success toast
  toast({
    title: "Success",
    description: "Operation completed successfully.",
  });

  // Error toast
  toast({
    variant: "destructive",
    title: "Error",
    description: "Something went wrong.",
  });
  ```

- The main Toaster component is imported from our custom UI component:
  - `import { Toaster } from "@/components/ui/sonner";`
  - This is ONLY used in the root layout.tsx file
  - DO NOT add Toaster components to individual pages

### TooltipProvider Usage Pattern - [2025-03-11 15:06:15]

- Always wrap components that use tooltips with a TooltipProvider
- Prefer wrapping the entire component with a single TooltipProvider at the top level
- Avoid nesting TooltipProviders as this can cause CSS issues and UI breakage
- When using tooltips in a component, ensure the following structure:
  ```tsx
  <TooltipProvider>
    <Tooltip>
      <TooltipTrigger>
        <InfoIcon className="h-4 w-4 ml-1 text-gray-400" />
      </TooltipTrigger>
      <TooltipContent>
        <p className="max-w-xs">Tooltip content here</p>
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
  ```
- If you have multiple tooltips in a component, wrap the entire component with a single TooltipProvider

### Component Variants - [2025-03-11 15:06:15]

- The Card component has been extended with a gradient variant:
  ```tsx
  <Card variant="gradient" variantKey="primary">
    <CardHeader>
      <CardTitle>Card Title</CardTitle>
    </CardHeader>
    <CardContent>
      <p>Card content</p>
    </CardContent>
  </Card>
  ```
- Available gradient keys:
  - `primary`: Blue to indigo gradient
  - `secondary`: Purple to pink gradient
  - `accent`: Amber gradient
  - `info`: Subtle blue gradient
  - `default`: Subtle gray gradient

### UI Animation Guidelines - [2025-03-11 15:06:15]

- Animations should be subtle and professional, not flashy or distracting
- Use longer intervals (3+ seconds) between animation changes
- Choose color schemes that align with the brand identity (blues, blacks)
- Implement proper cleanup to prevent memory leaks
- Use React's useId() hook for stable IDs in SVG elements
- Add aria-labels to animated elements for accessibility
- Test animations on both high and low-end devices to ensure performance

### Responsive Design Patterns - [2025-03-11 15:06:15]

- Start with a minimal, functional mobile design
- Add features and complexity for larger screens
- Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) to control visibility
- Hide descriptive text on small screens with `hidden md:inline-block`
- Show only essential icons/badges on mobile
- Maintain touch-friendly tap targets (min 44px) on all screen sizes
- Use flex-wrap for horizontal elements that might overflow
- Implement grid layouts with auto-fit/auto-fill for dynamic columns
- Set appropriate min/max widths to prevent extreme scaling
- Use responsive spacing utilities (p-2 sm:p-4 md:p-6)
- Maintain adequate whitespace on all screen sizes
- Reduce padding/margins proportionally on smaller screens
- Test at standard breakpoints: 640px, 768px, 1024px, 1280px

## LLM Integration Patterns

### AI Excellence Focus - [2025-03-11 15:06:15]

- The primary goal of all development is to make LLMs and AI agents shine in user interactions
- Every feature should be designed to showcase the intelligence of the AI
- Prioritize quality of AI outputs over quantity of features
- Key principles to follow:
  1. Craft sophisticated prompts that bring out the best in LLMs
  2. Implement post-processing to ensure professional formatting of AI outputs
  3. Design features that maintain context between user interactions
  4. Personalize AI responses based on user needs and preferences
  5. Continuously refine AI implementations based on user feedback

### LLM Implementation Best Practices - [2025-03-11 15:06:15]

- Always use the most appropriate model for each task:
  - Use Gemini 2.0 Flash for quick, responsive interactions
  - Use GPT-4 for complex reasoning and creative tasks
  - Use specialized models for specific domains when appropriate
- Implement robust error handling for AI interactions:
  - Gracefully handle API failures
  - Provide meaningful fallbacks when AI services are unavailable
  - Implement retry logic with exponential backoff
- Optimize prompts for each model's strengths and limitations
- Test AI outputs extensively with diverse inputs
- Monitor and log AI performance metrics to identify areas for improvement
- Regularly review and update prompts based on output quality

### Gemini Model Usage Pattern - [2025-03-11 15:06:15]

- Always use the centralized `getGeminiModel()` function from `nextjs-app/src/lib/gemini.ts` to access the Gemini model
- Never hardcode the model name in individual components or API routes
- The current model version is "gemini-2.0-flash-001"
- Environment variable: `GEMINI_API_KEY` (server-side only)
- Example usage:

  ```typescript
  import { getGeminiModel } from "@/lib/gemini";

  const generateContent = async (prompt: string) => {
    try {
      const model = getGeminiModel();
      const result = await model.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error("Error generating content with Gemini:", error);
      throw error;
    }
  };
  ```

### OpenRouter API Integration - [2025-03-11 15:06:15]

- The OpenRouter API is used for accessing the Llama 3.2 3b model in the Training Plan Creator
- Always use the `openRouter` instance from `@/lib/openrouter` for OpenRouter API calls
- The model name is "meta-llama/llama-3.2-3b-instruct"
- Environment variable: `OPENROUTER_API_KEY`
- Implementation in `nextjs-app/src/lib/openrouter.ts` and `nextjs-app/src/lib/llama.ts`
- Example usage:

  ```typescript
  import { openRouter } from "@/lib/openrouter";

  // Call OpenRouter with Llama 3.2 3b
  const response = await openRouter.chat.completions.create({
    model: "meta-llama/llama-3.2-3b-instruct",
    messages: [
      { role: "system", content: systemMessage },
      { role: "user", content: prompt },
    ],
    temperature: 0.7,
    max_tokens: 3500,
  });
  ```

### Two-Stage LLM Approach - [2025-03-11 15:06:15]

- The Training Plan Creator uses a two-stage approach for premium users:
  1. Gemini 2.0 Flash for resource recommendations
  2. Llama 3.2 3b for plan generation
- For free users, only the Llama 3.2 3b model is used with an enhanced prompt
- This approach ensures premium users get high-quality, current resources while maintaining good plan generation for all users
- Implementation in `nextjs-app/src/app/api/training-plan/enhanced-generate/route.ts`

### Structured Text Response Pattern - [2025-03-11 15:06:15]

- When working with LLM responses that need to be parsed into structured data, prefer using clear section headers over JSON
- Benefits of section-based extraction:
  - More reliable parsing with less complex code
  - Easier to debug and maintain
  - Less prone to JSON formatting errors from the LLM
  - Simpler extraction logic
- Implementation pattern:
  1. In the prompt, specify exact section headers (e.g., "QUESTIONS:", "EVALUATION TIPS:")
  2. Request numbered items within each section for easier parsing
  3. Use regex to extract content between section headers
  4. Process each section's content separately
- Example prompt structure:

  ```
  Format your response as follows:

  SECTION_1:
  1. First item
  2. Second item
  ...

  SECTION_2:
  1. First item
  2. Second item
  ...
  ```

- Always include fallback mechanisms for when the LLM doesn't follow the format exactly
- For HTML content, use simple text-to-HTML conversion rather than asking the LLM to generate HTML directly

### LLM Quality Control Patterns - [2025-03-11 15:06:15]

- When implementing LLM-based features, always include comprehensive quality control measures:
  1. **Enhanced Prompting**:
     - Use detailed system prompts with specific instructions
     - Include examples of desired output format and quality
     - Specify requirements for structure, completeness, and relevance
  2. **Parameter Tuning**:
     - Use lower temperature (0.5-0.7) for more consistent outputs
     - Adjust max_tokens based on the expected response length
     - Consider using top_p and frequency_penalty for diverse but controlled outputs
  3. **Output Validation**:
     - Implement comprehensive quality checks for LLM outputs
     - Validate minimum length, structure, and completeness
     - Check for presence of key terms relevant to the domain
     - Ensure proper sentence structure and punctuation
  4. **Fallback Mechanisms**:
     - Create high-quality fallback content for when LLM generation fails
     - Make fallbacks context-aware using user input parameters
     - Ensure fallbacks maintain the same structure and format as expected LLM outputs
  5. **Model Selection**:
     - Use smaller, more reliable models when possible
     - Implement model fallback chains (e.g., Llama → Gemini)
     - Balance performance with reliability based on the use case

### Feedback Collection Patterns - [2025-03-11 15:06:15]

- Every AI-powered tool should include at least one feedback mechanism
- Types of feedback mechanisms to implement:
  - Simple rating systems (1-5 stars, thumbs up/down)
  - Detailed feedback forms for specific aspects of AI output
  - In-context feedback options during tool usage
  - Follow-up emails requesting feedback after tool usage
- Best practices for feedback implementation:
  - Keep primary feedback mechanisms simple and non-intrusive
  - Offer more detailed feedback options as a secondary step
  - Clearly explain how feedback improves the AI
  - Thank users for providing feedback
  - Show appreciation for detailed feedback

## Testing Patterns

### Component Test Structure - [2025-03-11 15:06:15]

```typescript
// Always follow this structure for component tests
describe("ComponentName", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset any global mocks
  });

  it("renders required elements", () => {
    // Test basic rendering
  });

  it("handles user interactions", async () => {
    // Test user interactions
  });

  it("handles API interactions", async () => {
    // Test API calls
  });

  it("handles error cases", async () => {
    // Test error scenarios
  });
});
```

### Mock Component Patterns - [2025-03-11 15:06:15]

```typescript
// Pattern for mocking form components
jest.mock("@/components/ui/form", () => ({
  Form: ({ children }) => <div>{children}</div>,
  FormField: ({ render, name }) =>
    render({
      field: { value: "", onChange: jest.fn(), name },
    }),
  // ... other form components
}));

// Pattern for mocking select components
jest.mock("@/components/ui/select", () => ({
  Select: ({ children, name, ...props }) => (
    <select role="combobox" aria-label={name} title={name} {...props}>
      {children}
    </select>
  ),
  // ... other select components
}));
```

### API Test Structure - [2025-03-11 15:06:15]

1. Test successful API calls:
   - Mock successful responses
   - Verify response status and body
   - Verify API was called with correct parameters
2. Test validation errors:
   - Test with invalid or missing parameters
   - Verify 400 status code
   - Verify error messages
3. Test API errors:
   - Mock API failures
   - Verify proper error handling
   - Verify 500 status code
4. Test edge cases:
   - Empty responses
   - Malformed responses
   - Missing API keys

### Mock Prisma Client Pattern - [2025-03-11 15:06:15]

The project uses a standardized approach for mocking the Prisma client in API tests. This pattern is implemented in `nextjs-app/src/lib/test/prisma-mock.ts` and should be followed for all API tests.

Key components:

1. **TypeScript Interfaces**: Define interfaces for all mock storage objects to ensure type safety.
2. **Mock Implementation**: Create a mock implementation that mimics the Prisma client's behavior.
3. **Error Handling**: Implement consistent error handling across all mock methods.
4. **Test Setup**: Use the mock in tests by accessing the global mock instance.
5. **Creating Test Data**: Create test data using the mock Prisma client.
6. **Handling Relationships**: For many-to-many relationships, directly update the storage.
7. **API Route Params**: When testing API routes, use the correct pattern for params.
8. **Verifying Results**: Verify the results of API calls.

## Form Patterns

### Form Implementation - [2025-03-11 15:06:15]

1. Use React Hook Form for form state management
2. Use Zod for schema validation
3. Use Radix UI components for accessibility
4. Use toast notifications for feedback

### Form Validation - [2025-03-11 15:06:15]

1. Required fields:
   - Minimum length validation
   - Custom error messages
2. Optional fields:
   - Clear validation rules
   - Default values
3. Select fields:
   - Predefined options
   - Default selection

### Form Submission - [2025-03-11 15:06:15]

1. Loading state management
2. Error handling
3. Success feedback
4. Form reset
5. Data transformation

### Form Field Structure - [2025-03-11 15:06:15]

```typescript
<FormField
  control={form.control}
  name="fieldName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Label</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormDescription>Helper text</FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Error Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  // API call
  const response = await fetch("/api/endpoint");
  if (!response.ok) {
    throw new Error("API Error");
  }
  // Success handling
  toast({
    title: "Success",
    description: "Operation completed successfully",
  });
} catch (error) {
  // Error handling
  toast({
    title: "Error",
    description: "Operation failed. Please try again.",
    variant: "destructive",
  });
}
```

### API Response Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  const response = await fetch("/api/endpoint", {
    method: "METHOD",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  });

  // Parse the response data first
  let data;
  try {
    data = await response.json();
  } catch (parseError) {
    console.error("Error parsing response:", parseError);
    data = { fallbackData: true };
  }

  // Then check if the response is OK
  if (!response.ok) {
    throw new Error(data.error || "Default error message");
  }

  // Use the parsed data
  return data;
} catch (error) {
  console.error("Error:", error);
  // Handle the error appropriately
}
```

## Authentication and Authorization

### Authentication System - [2025-03-11 15:06:15]

- The application uses NextAuth.js for authentication with the following features:
  - Credentials provider (email/password)
  - Google OAuth provider
- Configuration in `nextjs-app/src/app/api/auth/[...nextauth]/auth.ts`
- Environment variables:
  ```
  NEXTAUTH_URL=http://localhost:3000
  NEXTAUTH_SECRET=your-secret-here
  GOOGLE_CLIENT_ID=your-google-client-id
  GOOGLE_CLIENT_SECRET=your-google-client-secret
  ```
- Authentication pages:
  - Sign-in page: `nextjs-app/src/app/auth/signin/page.tsx`
  - Sign-up page: `nextjs-app/src/app/auth/signup/page.tsx`
- Session management:
  - JWT strategy for session tokens
  - Session data stored in cookies
  - Session expiration configurable in NextAuth options

### Role-Based Access Control - [2025-03-11 15:06:15]

- Three-tier role system:
  - Superadmin (pgtipping1@gmail.com)
  - Admin
  - User
- Role hierarchy enforced through multiple layers:
  - API route authorization
  - Client-side component protection
  - Server-side session validation
- Role checks in API routes with proper error handling
- Protected routes with client-side redirects
- Real-time role updates with optimistic UI
- Exclusive superadmin privileges for role modification
- Protected superadmin account from role changes
- Role update API with proper validation
- Real-time UI feedback for role changes

## Feature-Specific Patterns

### Blog Post Creation Pattern - [2025-03-11 15:06:15]

- Blog posts can be created through two methods:
  1. Direct API method (Preferred):
     - Use `/api/posts` endpoint for database-driven posts
     - Use `/api/blog/generate` for LLM-assisted content creation
     - No filesystem operations required
     - Works consistently across all environments
  2. MDX file method (Legacy/Optional):
     - Store MDX files in filesystem
     - Requires manual file syncing across environments
     - More complex to maintain
     - Can cause deployment issues
- Key principles to follow:
  1. Prefer direct API method for new blog posts
  2. Use LLM assistance for professional content generation
  3. Store all content in database for consistency
  4. Avoid filesystem-based content when possible

### Blog Post Layout Pattern - [2025-03-11 15:06:15]

- Blog post content should use a constrained width to improve readability:
  ```jsx
  <article className="prose prose-lg max-w-4xl mx-auto">
    {/* Blog post content */}
  </article>
  ```
- Use black text for paragraph content to ensure readability
- Use Radix UI icons for a professional and consistent look
- Key aspects of this pattern:
  - Use `max-w-4xl` for blog post content to match comment section width
  - Avoid using `max-w-none` which would override parent width constraints
  - Center content with `mx-auto` for balanced white space on both sides
  - Maintain consistent width between article content and comments section
  - This width provides optimal readability while adding sufficient white space

### JD Developer Form Validation - [2025-03-11 15:06:15]

- The JD Developer form has been updated to make education, experience, and certifications optional. The only mandatory fields for generating job descriptions are:
  - Job title
  - Employment type
  - Position level
  - Industry
- The API validation schema in `nextjs-app/src/app/api/jd-developer/generate/route.ts` has been modified to make these fields optional by using `.default([])` instead of `.min(1, "...")`.
- The POST function has also been updated to ensure that all arrays are properly passed to the `generateJobDescription` function, even if they're not provided in the request.
- The UI already correctly labels these fields as optional:
  - Educational Requirements (Optional)
  - Professional Experience (Optional)
  - Required Certifications (Optional)

### Template Filtering Pattern - [2025-03-11 15:06:15]

- Templates are stored in the same database table as regular job descriptions
- Templates are identified by the `isTemplate` flag in the metadata
- Two-layer filtering approach is used to ensure proper separation:
  1. Database query filtering: `content: { not: { contains: '"isTemplate":true' } }`
  2. Parsed content verification: `if (parsedContent.metadata?.isTemplate === true) { return null; }`
- This double-checking approach ensures templates only appear in the templates list
- Always filter out null entries after parsing: `.filter(Boolean)`
- Handle JSON parsing errors gracefully with try/catch blocks
- Log parsing errors for debugging: `console.error(`Error parsing JD ${jd.id}:`, error);`

### Newsletter System Patterns - [2025-03-11 15:06:15]

- All newsletter routes must be under `/api/admin/newsletter/`
- All routes require admin role authentication
- Use Prisma's type-safe query builder
- Implement comprehensive error handling
- Return consistent response formats
- Database Models:
  - NewsletterSubscriber: Manages subscriber data and status
  - NewsletterTemplate: Stores reusable email templates
  - NewsletterSend: Tracks newsletter sending history
  - NewsletterReply: Handles subscriber responses
- Field Naming Conventions:
  - Use `createdAt` for creation timestamps
  - Use `updatedAt` for modification timestamps
  - Use descriptive names for status fields
  - Maintain consistent field names across models

## Development Workflow

### Command Execution Safety - [2025-03-11 15:06:15]

1. ALWAYS verify current directory before running any commands
2. Use `list_dir` to check directory structure
3. Navigate to correct directory if needed
4. Verify package.json exists in current directory before running npm commands
5. Document directory context in explanations
6. ALWAYS add a space before ALL terminal commands to ensure proper history tracking and prevent typo errors
   - Example: ` ls -la` instead of `ls -la`
   - Example: ` git status` instead of `git status`
   - Example: ` cd src` instead of `cd src`
   - This applies to all commands: ` npm`, ` git`, ` ls`, ` cd`, etc.

### Git Commit Approach - [2025-03-11 15:06:15]

- When committing changes to the repository, always use `git add .` instead of specifying individual file paths
- The correct approach for committing changes is:

  ```bash
  # Stage all changes
  git add .

  # Commit with a descriptive message
  git commit -m "Descriptive message about the changes"
  ```

- Git Commit Messages:
  - feat: New features
  - fix: Bug fixes
  - test: Test changes
  - docs: Documentation
  - refactor: Code improvements
  - style: Formatting changes

### Memory Bank Update Pattern - [2025-03-11 15:06:15]

- ALWAYS programmatically determine today's date when updating memory bank files
- Never use hardcoded dates in memory bank entries
- Use the following pattern to get the current date in YYYY-MM-DD format:
  ```bash
  # In terminal
  date +"%Y-%m-%d"
  ```
  ```javascript
  // In JavaScript
  const today = new Date().toISOString().split("T")[0];
  ```
- Apply the current date to all new entries in memory bank files:
  - Use the date for section headings: `## Current Focus (YYYY-MM-DD)`
  - Use the date for entry timestamps: `- ✅ UPDATED: Feature X (YYYY-MM-DD)`
  - Use the date for file headings: `# Progress Report - YYYY-MM-DD`

### Environment Configuration Pattern - [2025-03-11 15:06:15]

- Local Development:
  - `.env` file contains development configuration
  - Variables are commented with explanations
  - Duplicate entries are avoided
- Production:
  - Production values should be set in the deployment platform (Vercel)
  - Alternative: use `.env.production` for production values
  - Comments indicate which values to use in production
- Critical Variables:
  - `NEXTAUTH_URL`: The base URL of the application
  - `NEXTAUTH_SECRET`: Secret for NextAuth session encryption
  - `DATABASE_URL`: Connection string for the database
  - `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: Google OAuth credentials
  - `GEMINI_API_KEY`: API key for Gemini LLM
  - `OPENROUTER_API_KEY`: API key for OpenRouter (Llama model)

### Sensitive Information Handling - [2025-03-11 15:06:15]

- NEVER commit .env files to the repository
- The .env file should be listed in .gitignore
- Use .env.example to document required environment variables without actual values
- If .env is accidentally committed, it must be removed from the entire git history
- GitHub has push protection that blocks commits containing secrets
- If a push is rejected due to containing secrets, you must remove the secrets from the git history
- Never use the GitHub option to allow the secret, as this is a security risk

# ApplyRight Feature Implementation - June 14, 2023

## Document Parsing Strategy - [2023-06-14]

When implementing document parsing for the ApplyRight feature, we initially encountered issues with PDF.js integration. The PDF.js library required specific configuration to work properly in a Next.js environment, particularly with its worker files.

### Initial PDF.js Integration Issues

The main issue was that the PDF.js worker file couldn't be found during the build process, resulting in the error:

```
Error: ENOENT: no such file or directory, open 'C:\Users\pgeor\OneDrive\Documents\Web Dev\synthalyst\nextjs-app\node_modules\pdfjs-dist\build\pdf.js'
```

### Solution: Client-Side Only PDF Parsing

After researching alternatives, we implemented PDF support using the react-pdftotext package with dynamic imports to ensure it only runs on the client side. This approach avoids server-side rendering issues with the PDF.js dependency.

Key benefits of this approach:

1. Avoids server-side rendering issues with PDF.js
2. Uses dynamic imports to load the PDF parser only when needed
3. Provides a clean fallback for server-side rendering
4. Works well with Next.js without complex configuration
5. Memory-safe implementation

Implementation:

```typescript
async function parsePdf(file: File): Promise<string> {
  try {
    // Dynamically import the PDF parser only when needed (client-side only)
    if (typeof window === "undefined") {
      // We're on the server, return a message
      return "PDF parsing is only available in the browser. The file will be processed when viewed in the browser.";
    }

    // We're in the browser, dynamically import the PDF parser
    const pdfToTextModule = await import("react-pdftotext");
    const pdfToText = pdfToTextModule.default;

    const text = await pdfToText(file);
    return text.trim();
  } catch (error) {
    console.error("Error parsing PDF:", error);
    throw new Error(
      "Failed to extract text from PDF. Please try a different file format."
    );
  }
}
```

## UI Component Structure (2025-03-12)

The ApplyRight feature follows a step-by-step wizard pattern with the following components:

1. **FileUpload** - Handles resume file uploads with drag-and-drop and click-to-browse functionality
2. **JobDescription** - Allows users to input job description text with a single "Continue" button
3. **Transform** - Processes the resume against the job description
4. **Results** - Displays and allows download of transformed documents

### UI Improvements

- Made the entire drop area in FileUpload component clickable, not just the button
- Removed redundant "Next" button in job description step to avoid confusion with the "Continue" button
- Ensured consistent button placement and styling throughout the wizard flow

## API Integration

The ApplyRight feature uses the Gemini API for resume transformation. The API route is implemented at `/api/apply-right/transform` and includes:

1. Request validation using Zod
2. Error handling
3. Fallback mode for when the API is unavailable

## User Experience Considerations

1. Clear feedback through toast notifications
2. Step-by-step guided process
3. Responsive design for all screen sizes
4. Comprehensive error handling

## PDF Generation Implementation - [2023-06-15]

The ApplyRight feature now includes professional PDF generation for the transformed resumes and cover letters. This implementation uses the jsPDF library to create well-formatted PDF documents with proper headers, footers, and intelligent text layout.

### Key Features

1. **Professional Document Formatting**:

   - Document headers with titles
   - Page numbers in footers
   - Intelligent paragraph detection and formatting
   - Multi-page support with proper pagination
   - Heading detection and emphasis

2. **User Experience Improvements**:

   - Clear "Download PDF" buttons
   - Descriptive text explaining the PDF download feature
   - Success notifications when PDFs are downloaded
   - Consistent document properties for better organization

3. **Technical Implementation**:
   - Uses jsPDF library for PDF generation
   - Client-side generation for immediate download
   - No server-side processing required
   - Intelligent text parsing to maintain document structure

This enhancement significantly improves the user experience by providing professionally formatted documents that are ready for immediate use in job applications.

# ApplyRight Feature UI and PDF Improvements - [2025-03-12 06:45:00]

## Resume and Cover Letter Preview Enhancement

The ApplyRight feature's UI has been significantly improved with enhanced resume and cover letter previews. Key improvements include:

1. **Intelligent Section Detection**:

   - Automatically identifies and styles different resume sections (summary, experience, education, etc.)
   - Detects and properly formats contact information
   - Recognizes and formats company/position information

2. **Enhanced Bullet Point Rendering**:

   - Proper indentation based on original formatting
   - Visual bullet points with consistent styling
   - Proper spacing and alignment

3. **Typography Improvements**:

   - Better font choices (sans-serif for resume, serif for cover letter)
   - Improved spacing and line height
   - Better text color management for readability

4. **Hydration Error Fix**:
   - Fixed HTML structure issue where a Badge component (div) was incorrectly placed inside a paragraph tag
   - Replaced p tag with properly styled div to maintain visual appearance while fixing the error

## PDF Generation Enhancement

The PDF generation for both resumes and cover letters has been significantly improved:

1. **Professional Layout**:

   - Added proper headers with candidate name and contact information
   - Improved section headers with background colors and proper spacing
   - Better page margins and content flow
   - Professional footer with page numbers

2. **Intelligent Content Processing**:

   - Automatically extracts and positions candidate name, contact info, and dates
   - Detects and properly formats section headers
   - Recognizes and formats bullet points with proper indentation
   - Identifies company/position information and applies appropriate styling

3. **Dynamic Filename Generation**:

   - Creates filenames based on candidate name when available
   - Adds appropriate file type suffix (Resume/Cover_Letter)

4. **Typography and Styling**:
   - Improved font selection and sizing
   - Better text color management for readability
   - Proper spacing between sections and paragraphs
   - Consistent styling throughout the document

These improvements significantly enhance the user experience by providing more professional-looking previews and downloads, making the ApplyRight feature more valuable to users.

### ApplyRight UI and PDF Improvements - [2023-07-15]

- The resume preview component uses intelligent section detection to apply appropriate styling:

  - Candidate name (usually at the top, often with asterisks) gets large, centered styling
  - Contact information (contains |, @, or brackets) gets centered, smaller styling
  - Section headers (contains \*\* or starts with #) get bold styling with a bottom border
  - Bullet points are rendered with CSS styling instead of text bullets to avoid duplication
  - Company/position lines (contains Ltd, Inc, LLC, or dates) get semi-bold styling
  - Summary sections get slightly lighter text color

- The cover letter preview component uses special formatting for different sections:

  - Date lines (contains month names or date formats) are right-aligned
  - Sender and recipient information get proper spacing
  - Greeting lines (starts with "Dear" or "To Whom") get extra spacing
  - Closing lines (Sincerely, Best regards, etc.) get special formatting
  - Signature lines get bold styling with extra spacing
  - All text uses serif fonts for a more formal appearance

- Resume PDF generation includes:

  - Professional header with light gray background
  - Candidate name extraction from the first few lines
  - Contact information display below the name
  - Section headers with background color and divider lines
  - Bullet points with proper indentation based on the original spacing
  - Special handling for company/position lines
  - Different styling for summary sections
  - Page numbers in the footer
  - Dynamic filename based on candidate name

- Cover Letter PDF generation includes:
  - Proper business letter format with wider margins
  - Intelligent extraction of sender, recipient, and date information
  - Special formatting for greeting and closing sections
  - Proper paragraph spacing for readability
  - Page numbers in the footer
  - Dynamic filename based on sender name

## ApplyRight Feature Improvements - March 12, 2025

### LLM Model Selection

- Gemini 2.0 Flash provides significantly better quality output than Gemini 1.5 Flash for resume and cover letter generation
- The model is better at following specific formatting instructions and avoiding placeholder text
- Response times are comparable between the two models

### Prompt Engineering Insights

- Explicit instructions to NEVER use placeholder text are critical for quality output
- Including examples of desired output format (e.g., "leading to a 20% increase" instead of "Quantifiable Achievement (e.g., 20%)") significantly improves results
- For cover letter generation, specific instructions about paragraph alignment and avoiding generic terms like "Platform" are necessary
- The LLM responds well to numbered lists of specific instructions in the prompt

### Fallback Function Design

- Regex replacements are effective for handling common placeholder patterns
- Maintaining separate fallback functions for resume and cover letter generation provides better control over the output quality
- The fallback functions should mirror the LLM's expected output format as closely as possible

### UI/UX Considerations

- Keyword matching visualization should accurately reflect the actual matches in the content
- Green checkmarks provide clear visual feedback for matched keywords
- Hover tooltips with match percentages add valuable context for users
- The overall match score should align with the visual indicators (all green = 100%)

These insights will help maintain high-quality output in the ApplyRight feature and can be applied to other LLM-powered features in the application.

## Accessibility Standards [2025-03-12 20:24:00]

- All UI elements must meet WCAG 2.1 AA standards for color contrast
- Navigation links use text-gray-900 for sufficient contrast against light backgrounds
- Form elements must have proper labels or aria-labels
- Buttons without visible text must have aria-labels
- All interactive elements must have proper focus states
- The application has achieved a perfect accessibility score of 100/100
- Do not attempt to fix accessibility issues that have already been resolved

# CSS Architecture Rules - March 12, 2024, 20:45:00

## CSS File Organization

1. Critical CSS (`/src/app/critical.css`):

   - Only include above-the-fold styles
   - Keep file size under 14KB (compressed)
   - Use CSS variables for theming

2. Global CSS (`/src/app/globals.css`):

   - Include Tailwind directives
   - Define CSS variables
   - Base element styles

3. Non-Critical CSS (`/public/styles/non-critical.css`):
   - Below-the-fold styles
   - Utility classes
   - Component variations
   - Animations and transitions

## CSS Loading Rules

1. Critical CSS:

   - Must be inlined in the head
   - No render-blocking imports
   - Use preload for critical fonts

2. Non-Critical CSS:
   - Must be loaded asynchronously
   - Include fallback for no-JS
   - Use resource hints

## CSS Best Practices

1. Mobile-First Development:

   - Start with mobile styles
   - Use standard breakpoints
   - Test on multiple devices

2. Performance:

   - Minimize specificity
   - Avoid deep nesting
   - Use utility classes
   - Consolidate duplicate styles

3. Accessibility:

   - Maintain WCAG contrast ratios
   - Provide focus indicators
   - Support reduced motion

4. Dark Mode:
   - Use CSS variables
   - Test color contrast
   - Maintain readability

# Cursor Rules - Synthalyst Web Application [2025-03-13]

## Project Structure [2025-03-13]

### Directory Organization [2025-03-13]

- The main application code is in the `nextjs-app` directory
- All development should be done within this directory
- The development server runs on port 3001

### File Naming Conventions [2025-03-13]

- Use kebab-case for file names (e.g., `file-name.tsx`)
- Use PascalCase for component names (e.g., `ComponentName.tsx`)
- Use camelCase for utility functions and hooks (e.g., `useHookName.ts`)

## SEO Implementation [2025-03-13]

### Metadata [2025-03-13]

- Use Next.js Metadata API for all metadata
- Define metadata in layout.tsx for site-wide metadata
- Override metadata in page.tsx files for page-specific metadata
- Include title, description, and OpenGraph data for all pages

### JSON-LD [2025-03-13]

- Implement JSON-LD structured data for all pages
- Use the script tag with type="application/ld+json"
- Include appropriate schema based on page content
- Validate JSON-LD using Google's Structured Data Testing Tool

### Sitemap and Robots [2025-03-13]

- Use dynamic sitemap.ts for sitemap generation
- Use dynamic robots.ts for robots.txt configuration
- Do not create static files in the public directory for these

## Accessibility Guidelines [2025-03-13]

### Color Contrast [2025-03-13]

- Ensure all text has sufficient color contrast (4.5:1 for normal text, 3:1 for large text)
- Use text-gray-900 instead of text-gray-700 for better contrast
- Update muted-foreground color variables in both light and dark modes

### Heading Structure [2025-03-13]

- Use proper heading hierarchy (h1 -> h2 -> h3)
- Avoid skipping heading levels
- Each page should have only one h1 element

### ARIA Attributes [2025-03-13]

- Add aria-label to buttons without visible text
- Add proper labels to form elements
- Use aria-hidden for decorative elements

## Performance Optimization [2025-03-13]

### CSS Strategy [2025-03-13]

- Use critical.css for above-the-fold content
- Load non-critical CSS asynchronously
- Use Tailwind CSS for utility-first styling
- Minimize custom CSS

### JavaScript Optimization [2025-03-13]

- Use next/script with appropriate strategy
- Implement code splitting for large components
- Defer non-critical JavaScript
- Minimize third-party scripts

### Image Optimization [2025-03-13]

- Use next/image for automatic optimization
- Implement responsive images with srcset
- Use WebP format when supported
- Implement lazy loading for below-the-fold images

## Component Patterns [2025-03-13]

### Layout Components [2025-03-13]

- Use RootLayout for site-wide layout
- Define page-specific layouts as needed
- Include proper metadata in layout components

### Page Components [2025-03-13]

- Use page.tsx for page components
- Override metadata in page components
- Implement JSON-LD in page components

### UI Components [2025-03-13]

- Use shadcn/ui components when available
- Create custom components when needed
- Ensure all components are accessible

## API Patterns [2025-03-13]

### API Routes [2025-03-13]

- Use Next.js API routes for backend functionality
- Implement proper error handling
- Use TypeScript for type safety
- Validate input with Zod

### Data Fetching [2025-03-13]

- Use server components for data fetching when possible
- Implement proper error handling
- Use TypeScript for type safety
- Cache data when appropriate

## Testing Guidelines [2025-03-13]

### Component Testing [2025-03-13]

- Test rendering and user interactions
- Test form validation and submission
- Test loading states and error handling
- Test accessibility

### API Testing [2025-03-13]

- Test success and error cases
- Validate response structure
- Test pagination and filtering
- Mock external dependencies

## SEO and Performance Optimization Patterns - [2025-03-13 01:55:00]

- Metadata implementation:

  - Use the `metadata` export in layout.tsx or page.tsx files
  - Include title, description, keywords, and OpenGraph data
  - Add canonical URLs using the alternates property
  - Example:
    ```typescript
    export const metadata: Metadata = {
      title: "Page Title | Synthalyst",
      description: "Page description for better SEO",
      keywords: ["keyword1", "keyword2"],
      openGraph: {
        title: "Page Title | Synthalyst",
        description: "Page description for better SEO",
        url: "https://synthalyst.com/page-path",
        type: "website",
        images: [{ url: "/icons/og-image.png", width: 1200, height: 630 }],
      },
      twitter: {
        card: "summary_large_image",
        title: "Page Title | Synthalyst",
        description: "Page description for better SEO",
        images: ["/icons/twitter-image.png"],
      },
      alternates: {
        canonical: "https://synthalyst.com/page-path",
      },
    };
    ```

- Structured data implementation:

  - Use JSON-LD format in layout.tsx or page.tsx files
  - Add the script tag in the component's return statement
  - Example:

    ```typescript
    const jsonLd = {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      name: "Application Name",
      description: "Application description",
    };

    return (
      <>
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
        />
        {children}
      </>
    );
    ```

- Resource hints for performance:

  - Add preconnect for domains that will be used
  - Add dns-prefetch for domains that might be used
  - Example:
    ```html
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin="anonymous"
    />
    <link rel="dns-prefetch" href="https://res.cloudinary.com" />
    ```

- JavaScript optimization:

  - Use conditional execution for deferred JavaScript
  - Implement Intersection Observer for lazy loading
  - Preload critical images
  - Example:

    ```javascript
    // Defer non-critical JavaScript
    if (document.readyState === "complete") {
      deferJsLoad();
    } else {
      window.addEventListener("load", deferJsLoad);
    }

    // Lazy load images with Intersection Observer
    if ("IntersectionObserver" in window) {
      const lazyLoadObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const target = entry.target;
            if (target.dataset.src) {
              target.src = target.dataset.src;
              target.removeAttribute("data-src");
            }
            lazyLoadObserver.unobserve(target);
          }
        });
      });

      document.querySelectorAll("[data-src]").forEach((el) => {
        lazyLoadObserver.observe(el);
      });
    }
    ```

- Webpack configuration for performance:
  - Implement code splitting with cache groups
  - Add better minification settings for production
  - Example:
    ```javascript
    // In next.config.js
    config.optimization = {
      splitChunks: {
        chunks: "all",
        cacheGroups: {
          vendor: {
            name: "vendor",
            test: /node_modules/,
            priority: 20,
          },
          common: {
            name: "common",
            minChunks: 2,
            priority: 10,
          },
        },
      },
    };
    ```

## Fixed Issues [2025-03-13 06:20:00]

### Logo 404 Error

- The application was showing a 404 error for logo.png in the console
- Fixed by copying the logo.png file to the public directory
- This ensures the logo loads correctly without any console errors

### Interview Prep Plan Formatting

- TIMELINE and PHASE sections were not properly formatted in the interview prep plan
- Fixed by implementing proper regex patterns and styling in the SimpleMarkdown component
- Enhanced the PDF export component to properly handle these special sections
- This improves readability and professional appearance of the interview prep plan

### React Server-Side Rendering Best Practices - [2025-03-13 06:50:00]

- Use `useIsomorphicLayoutEffect` instead of `useLayoutEffect` for components that might be rendered on the server
- The utility is located at `src/lib/useIsomorphicLayoutEffect.ts`
- This prevents the "useLayoutEffect does nothing on the server" warning
- Implementation:

  ```typescript
  import { useLayoutEffect, useEffect } from "react";

  // Use useLayoutEffect on the client, but fall back to useEffect during SSR
  const useIsomorphicLayoutEffect =
    typeof window !== "undefined" ? useLayoutEffect : useEffect;

  export default useIsomorphicLayoutEffect;
  ```

- Import and use it like this:

  ```typescript
  import useIsomorphicLayoutEffect from "@/lib/useIsomorphicLayoutEffect";

  function MyComponent() {
    useIsomorphicLayoutEffect(() => {
      // Your layout effect code here
    }, []);

    return <div>My Component</div>;
  }
  ```

### SimpleMarkdown Component Patterns - [2025-03-13 06:50:00]

- The SimpleMarkdown component in `src/app/interview-prep/page.tsx` handles custom markdown formatting
- Special section handling requires regex patterns for both:
  - Sections at the beginning of lines (e.g., `^TIMELINE:`)
  - Sections in the middle of text (e.g., `(\S+\s*)TIMELINE:`)
- Example pattern for handling both cases:
  ```typescript
  // Handle when it appears in the middle of text
  formattedText = formattedText.replace(
    /(\S+\s*)TIMELINE:/g,
    '$1<br /><span class="text-md font-bold text-primary/90 mt-4 mb-2 inline-block">TIMELINE:</span>'
  );
  // Also handle when it appears at the beginning of a line
  formattedText = formattedText.replace(
    /^TIMELINE:/gm,
    '<span class="text-md font-bold text-primary/90 mt-4 mb-2 inline-block">TIMELINE:</span>'
  );
  ```
- The component uses a series of regex replacements to transform markdown-like syntax into styled HTML
- Order of replacements matters to avoid conflicts between patterns

### SHA224 Crypto Module Fix - [2025-03-13 18:20:00]

- If encountering "Cannot set properties of undefined (setting 'SHA224')" error:
  1. Ensure crypto-browserify is properly configured as a fallback for the crypto module
  2. Use the crypto-polyfill.js utility to initialize the crypto library before PDF operations
  3. Initialize the crypto polyfill in components that use PDF generation
  4. Use the pdf-utils.js utility functions for safer PDF generation and download
  5. Modify webpack configuration to prevent mangling of crypto-related properties
- The error occurs in production builds due to minification issues with the crypto library
- The solution involves:
  - Proper initialization of the crypto library
  - Prevention of property mangling during minification
  - Safe utility functions for PDF operations
- Affected components:
  - TrainingPlanClient
  - TrainingPlanPDF
  - PDFRenderer
  - Any component that uses PDF generation

### TypeScript Type Checking Strategy - [2025-03-13 19:30:00]

- The project uses a phased approach to TypeScript type checking:

  1. Phase 1: Use relaxed type checking with test files excluded
  2. Phase 2: Fix critical production code type errors
  3. Phase 3: Fix test file type errors
  4. Phase 4: Enable strict type checking

- Type checking can be run with `npm run typecheck`
- A custom TypeScript configuration is used: `tsconfig.typecheck.json`
- The Next.js configuration is set to use this custom TypeScript config
- Common type errors to fix:

  - Next.js 15 route parameters should use `Promise<{ id: string }>` type
  - Prisma schema mismatches (properties that don't exist in the schema)
  - Component prop type errors (props that don't match component definitions)
  - Missing type declarations for external libraries

- Documentation for the type checking plan is in `TYPE_CHECKING_PLAN.md`

## TypeScript Type Checking [2025-03-14 12:00:00]

The project uses TypeScript for type safety. We've implemented a comprehensive type checking strategy:

1. **Component Props**: All component props must be properly typed with interfaces or types.

   - Example: `interface BreadcrumbProps { items: BreadcrumbItem[]; className?: string; }`
   - Components should destructure props in their function signatures
   - Optional props should use the `?` syntax

2. **API Routes**: API routes should validate input with Zod and have proper type annotations.

   - Use Zod schemas for request validation
   - Explicitly type request handlers with appropriate return types
   - Handle type mismatches with proper error messages

3. **Type Assertions**: Use `@ts-expect-error` comments sparingly and only when necessary.

   - Always include a clear explanation of why the error is being suppressed
   - Example: `// @ts-expect-error - TypeScript doesn't preserve required properties when spreading`
   - Prefer fixing the underlying type issue over suppressing errors

4. **Library Compatibility**: Handle third-party library type issues with appropriate workarounds.

   - Use type assertions when necessary for library compatibility
   - Create adapter functions or wrapper components for problematic libraries
   - Document any workarounds in comments

5. **Type Checking Process**:
   - Run `npm run typecheck` before committing changes
   - Address all type errors before merging code
   - Update TYPE_CHECKING_PLAN.md with progress and next steps

This approach has successfully eliminated all TypeScript errors in the codebase, improving code quality and reducing potential runtime errors.

### CSS Conflict Resolution Patterns - [2025-03-14 15:35:00]

- When encountering styling differences between development and production environments:
  1. Inspect the production environment to identify conflicting CSS classes
  2. Create custom classes with the `synthalyst-` prefix to avoid conflicts
  3. Use higher specificity selectors or `!important` flags when necessary
  4. Implement responsive behavior using media queries
  5. Test changes in both development and production environments
- Common sources of CSS conflicts:
  - Non-critical CSS loaded asynchronously in production
  - Third-party CSS overriding application styles
  - CSS ordering differences in production builds
  - Minification and optimization changing CSS specificity
- Example solution pattern:

  ```css
  /* Custom class with prefix */
  .synthalyst-custom-element {
    display: flex !important;
    flex-direction: column;
  }

  /* Responsive behavior */
  @media (min-width: 640px) {
    .synthalyst-custom-element {
      flex-direction: row !important;
    }
  }
  ```

- Always maintain responsive behavior when fixing CSS conflicts
- Document CSS fixes in comments for future reference

## Accessibility and Performance Insights - [2025-03-14 21:30:00]

### Accessibility Audit Results - [2025-03-14 21:30:00]

- Critical accessibility issues identified:
  - Buttons without accessible names in the Training Plan page
  - Color contrast issues with links (3.67 ratio, below the required 4.5:1)
- Overall accessibility score: 90/100
- Prioritized recommendations:
  - Add proper labels to all interactive elements
  - Improve color contrast for better readability
  - Fix low contrast text for better readability
- All buttons must have accessible names through one of these methods:
  - Inner text visible to screen readers
  - aria-label attribute
  - aria-labelledby attribute
  - title attribute
  - Explicit or implicit label
- Color contrast must meet WCAG standards:
  - Text must have a contrast ratio of at least 4.5:1 against its background
  - Large text (18pt or 14pt bold) must have a contrast ratio of at least 3:1

### Performance Audit Results - [2025-03-14 21:30:00]

- Performance issues identified:
  - Slow Largest Contentful Paint (LCP): 3031ms (failing Core Web Vital)
  - Slow First Contentful Paint (FCP): 1668ms
  - High JavaScript execution time
  - Total Time to Interactive (TTI): 37718ms
- Overall performance score: 52/100
- Prioritized recommendations:
  - Improve Largest Contentful Paint (LCP)
  - Reduce JavaScript execution time
- Core Web Vitals targets:
  - LCP should be under 2.5 seconds
  - FID (First Input Delay) should be under 100ms
  - CLS (Cumulative Layout Shift) should be under 0.1
- Performance optimization strategies:
  - Optimize CSS loading strategy
  - Implement JavaScript optimization techniques
  - Configure image optimization
  - Reduce render-blocking resources
  - Implement code splitting and lazy loading
  - Optimize server-side rendering
  - Minimize main thread work

## Accessibility Best Practices - [2025-03-14 21:30:00]

### Button Accessibility - [2025-03-14 21:30:00]

- All buttons must have accessible names through one of these methods:
  - Inner text visible to screen readers
  - aria-label attribute
  - aria-labelledby attribute
  - title attribute
  - Explicit or implicit label
- Icon-only buttons must always have an aria-label attribute
- Examples of proper button accessibility:

  ```tsx
  // Button with icon only
  <Button
    type="button"
    variant="ghost"
    size="icon"
    onClick={handleClick}
    aria-label="Remove item"
  >
    <X className="h-4 w-4" />
  </Button>

  // Select trigger with accessible name
  <SelectTrigger className="w-32" aria-label="Select duration unit">
    <SelectValue placeholder="Unit" />
  </SelectTrigger>
  ```

### Color Contrast - [2025-03-14 21:30:00]

- All text must have a contrast ratio of at least 4.5:1 against its background
- Large text (18pt or 14pt bold) must have a contrast ratio of at least 3:1
- Use the "default" button variant instead of "outline" for better contrast
- Examples of proper color contrast:
  ```tsx
  // Good contrast with default variant
  <Button asChild variant="default">
    <Link href="/blog/training-plan-creator-guide">
      <HelpCircle className="mr-2 h-4 w-4" />
      Read the comprehensive guide
    </Link>
  </Button>
  ```

## Feedback System Implementation [2025-03-14 23:45:00]

### Dual Storage Strategy

- The feedback system uses a dual storage strategy:
  - Primary: Prisma database with AppFeedback model
  - Fallback: File-based JSON storage in feedback-data.json
- The system attempts to use Prisma first, and if it fails (e.g., due to missing model or permissions), it falls back to file storage
- The fallback mechanism is transparent to users, who receive a success message in both cases

### File Path Resolution

- The feedback-data.json file must be stored in the nextjs-app directory
- Path resolution uses process.cwd() which can vary depending on where the server is started
- Always use path.resolve() with conditional logic to ensure the file is stored in the correct location:

```typescript
const feedbackFilePath = path.resolve(
  process.cwd().includes("nextjs-app")
    ? process.cwd()
    : path.join(process.cwd(), "nextjs-app"),
  "feedback-data.json"
);
```

### Prisma Type Extensions

- The AppFeedback model may not be recognized by TypeScript in the Prisma client
- Use type assertions to extend the Prisma client type:

```typescript
type PrismaWithAppFeedback = typeof prisma & {
  appFeedback: {
    // Define methods and their types here
    findMany: (args?: {
      where?: { appName?: string };
      orderBy?: { createdAt: "asc" | "desc" };
    }) => Promise<
      Array<{
        // Define return type here
        id: string;
        appName: string;
        // Other fields...
      }>
    >;
    // Other methods...
  };
};
```

### Debugging Techniques

- Add comprehensive logging throughout the feedback system
- Log file paths, existence checks, and data read/write operations
- Create diagnostic scripts (check-feedback.mjs, check-cwd.js) for troubleshooting
- Use try-catch blocks with detailed error logging including stack traces

### Server Startup Location

- Always start the development server from the nextjs-app directory
- Use `cd nextjs-app && npm run dev` to ensure correct working directory
- Check the current directory with `pwd` before starting the server
- Verify the presence of package.json with `ls -la package.json`

## Module System Configuration [2025-03-14 23:50:00]

- The application uses CommonJS module format (require/module.exports) instead of ES modules
- Configuration files (tailwind.config.ts, postcss.config.ts) must use module.exports syntax
- Utility scripts use .cjs extension to ensure they are treated as CommonJS modules
- When creating new configuration files, always use module.exports syntax
- When creating new utility scripts, use .cjs extension if they need to be executed directly
- The package.json does NOT have "type": "module" to ensure CommonJS compatibility

## Prisma Model Casing Pattern - March 14, 2025

When working with Prisma models in code:

1. Always use camelCase for model names when accessing them through the Prisma client:

   - `prisma.questionLibrary` (correct)
   - `prisma.QuestionLibrary` (incorrect)
   - `prisma.userSavedQuestion` (correct)
   - `prisma.UserSavedQuestion` (incorrect)

2. Ensure interface definitions match the actual database schema:

   - Make fields nullable in TypeScript interfaces if they can be null in the database
   - Example: `answer: string | null` instead of just `answer: string`

3. This pattern applies to all Prisma client operations:
   - findMany
   - findUnique
   - findFirst
   - create
   - update
   - delete
   - count
   - etc.

## Audio Component Integration Pattern - March 14, 2025

When working with audio components in the application:

1. Import audio components from the components library:

   ```typescript
   import {
     AudioRecorder,
     TextToSpeechPlayer,
   } from "@/components/interview-prep";
   ```

2. Add state for audio data:

   ```typescript
   const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
   const [audioUrl, setAudioUrl] = useState<string | null>(null);
   const [isAudioMode, setIsAudioMode] = useState(false);
   ```

3. Handle audio recording completion:

   ```typescript
   const handleRecordingComplete = (blob: Blob, url: string) => {
     setAudioBlob(blob);
     setAudioUrl(url);
   };
   ```

4. Include audio URL in API requests:

   ```typescript
   interface RequestBody {
     // Other fields
     audioUrl?: string;
   }

   const requestBody: RequestBody = {
     // Other fields
     responseText: isAudioMode ? "Audio response submitted" : responseText,
   };

   if (isAudioMode && audioUrl) {
     requestBody.audioUrl = audioUrl;
   }
   ```

5. Add UI toggle for switching between text and audio modes:

   ```tsx
   <div className="flex items-center justify-end space-x-2 mb-2">
     <Label
       htmlFor="input-mode"
       className={isAudioMode ? "text-primary" : "text-muted-foreground"}
     >
       {isAudioMode ? "Voice Response" : "Text Response"}
     </Label>
     <Switch
       id="input-mode"
       checked={isAudioMode}
       onCheckedChange={toggleInputMode}
     />
   </div>
   ```

6. Conditionally render audio or text input based on mode:

   ```tsx
   {
     isAudioMode ? (
       <AudioRecorder
         onRecordingComplete={handleRecordingComplete}
         maxDuration={2 * 60 * 1000}
         showPlayer={true}
         showProgress={true}
       />
     ) : (
       <textarea
         value={responseText}
         onChange={(e) => setResponseText(e.target.value)}
       />
     );
   }
   ```

7. For text-to-speech, use the TextToSpeechPlayer component:

   ```tsx
   <TextToSpeechPlayer text={textToRead} showSettings={false} />
   ```

8. When displaying responses, handle both text and audio:
   ```tsx
   {
     audioUrl ? (
       <div>
         <audio src={audioUrl} controls />
         <p>Audio response submitted</p>
       </div>
     ) : (
       <p>{responseText}</p>
     );
   }
   ```

### AudioRecorder Component Pattern - March 14, 2025

- The AudioRecorder component provides high-quality audio recording for the Mock Interview feature
- Key implementation details:

  ```tsx
  // Import the component
  import { AudioRecorder } from "@/components/interview-prep/AudioRecorder";

  // Use the component with callback for handling the completed recording
  <AudioRecorder
    onRecordingComplete={(blob, url) => {
      // Handle the recording blob and URL
      setAudioBlob(blob);
      setAudioUrl(url);
    }}
    maxDuration={120000} // 2 minutes in milliseconds
    showPlayer={true}
    showProgress={true}
    autoRequestPermission={true}
  />;
  ```

- Configuration options:

  - `onRecordingComplete`: Callback function that receives the audio blob and URL
  - `maxDuration`: Maximum recording duration in milliseconds (default: 2 minutes)
  - `showPlayer`: Whether to show the audio player (default: true)
  - `showProgress`: Whether to show the progress bar (default: true)
  - `autoRequestPermission`: Whether to auto-request microphone permission (default: true)

- Audio quality settings:

  - Uses "audio/webm;codecs=opus" format for optimal voice quality
  - Disables noise reduction, echo cancellation, and auto gain control
  - Uses 48000Hz sample rate for better voice clarity
  - Configures mono recording (single channel) for voice

- UI feedback features:

  - Real-time status messages that update as recording progresses
  - Color coding (red for recording, green for success)
  - Button animations for better click feedback
  - Warning messages when approaching maximum duration
  - Progress bar showing recording duration

- Error handling:

  - Descriptive error messages for common issues
  - Clear instructions for resolving permission problems
  - Visual indicators for error states

- Best practices:
  - Always provide an onRecordingComplete handler
  - Consider mobile users with appropriate button sizes
  - Test on different browsers (Chrome, Firefox, Safari)
  - Provide alternative text input for accessibility

# Cursor Rules for Synthalyst Project

## Project Structure (2025-03-16)

- `nextjs-app/`: Main Next.js application
  - `src/`: Source code
    - `app/`: Next.js App Router
      - `admin/`: Admin dashboard pages
      - `api/`: API routes
      - `auth/`: Authentication pages
      - `blog/`: Blog pages
      - `dashboard/`: User dashboard
      - `tools/`: Tools pages
    - `components/`: Reusable components
    - `lib/`: Utility functions and libraries
    - `styles/`: Global styles
    - `types/`: TypeScript type definitions
  - `public/`: Static assets
  - `prisma/`: Prisma schema and migrations
  - `tests/`: Test files
- `memory-bank/`: Project documentation

## Coding Patterns (2025-03-16)

### Error Handling

1. **API Routes**:

   - Always use try-catch blocks for database operations
   - Return appropriate HTTP status codes
   - Include meaningful error messages
   - Log errors to console in development
   - Check for model/table existence before querying
   - Use SQL queries to verify table existence in the database
   - Initialize default values for all data variables to prevent undefined errors

2. **Frontend Components**:

   - Implement error boundaries for critical components
   - Use loading states for async operations
   - Provide fallback UI for error states
   - Handle network errors gracefully
   - Use optional chaining for potentially undefined properties
   - Add null checking for user properties to prevent undefined errors

3. **Authentication**:
   - Verify user authentication before accessing protected routes
   - Check user roles for admin-only features
   - Handle session expiration gracefully
   - Redirect unauthenticated users to login page
   - Use try-catch blocks around authentication checks
   - Implement fallbacks for authentication failures

### Database Operations

1. **Prisma Queries**:

   - Use transactions for related operations
   - Include error handling for all database operations
   - Implement pagination for large data sets
   - Use appropriate filters and sorting
   - Check for table existence before querying
   - Use raw SQL queries when necessary for complex operations
   - Verify model existence before attempting CRUD operations

2. **Data Validation**:
   - Validate input data before database operations
   - Use zod for schema validation
   - Sanitize user input to prevent injection attacks
   - Implement rate limiting for write operations
   - Provide meaningful error messages for validation failures

### Component Patterns

1. **Form Components**:

   - Use react-hook-form for form handling
   - Implement client-side validation
   - Show loading states during submission
   - Disable submit button when form is invalid
   - Provide clear error messages
   - Use controlled components for form inputs

2. **Layout Components**:

   - Create responsive layouts using Tailwind CSS
   - Implement mobile-first design
   - Use CSS Grid and Flexbox for complex layouts
   - Create reusable layout components
   - Ensure consistent spacing and alignment

3. **UI Components**:
   - Use shadcn/ui components for consistent design
   - Implement dark mode support
   - Ensure accessibility compliance
   - Create reusable UI components
   - Use Tailwind CSS for styling
   - Ensure all SelectItem components have non-empty values

### API Integration

1. **External APIs**:

   - Implement retry logic for failed requests
   - Use environment variables for API keys
   - Create service classes for API integration
   - Handle rate limiting and quotas
   - Implement caching for frequently used data
   - Use try-catch blocks for all API calls

2. **Authentication**:
   - Use NextAuth.js for authentication
   - Implement role-based access control
   - Secure API routes with authentication middleware
   - Handle token refresh automatically
   - Store tokens securely

### State Management

1. **React State**:

   - Use React hooks for local state
   - Implement context for shared state
   - Use reducers for complex state logic
   - Avoid prop drilling
   - Initialize state with default values to prevent undefined errors

2. **Server State**:
   - Use SWR for data fetching
   - Implement optimistic updates
   - Handle loading and error states
   - Use revalidation for stale data
   - Implement pagination and infinite scrolling

## User Preferences (2025-03-16)

1. **Code Style**:

   - Use TypeScript for all new code
   - Follow ESLint and Prettier configurations
   - Use meaningful variable and function names
   - Write comments for complex logic
   - Create reusable utility functions
   - Use proper typing for all variables and functions

2. **UI/UX Preferences**:

   - Implement clean, minimalist design
   - Use consistent color scheme
   - Ensure responsive design for all screen sizes
   - Prioritize accessibility
   - Use animations sparingly
   - Implement dark mode support
   - Ensure consistent button heights and alignment

3. **Documentation**:
   - Update memory-bank files for significant changes
   - Document API endpoints
   - Create README files for new features
   - Document environment variables
   - Update .cursorrules for new patterns

## Project-Specific Patterns (2025-03-16)

### Email Service

1. **Implementation**:

   - Use unified email service in `nextjs-app/src/lib/email.ts`
   - Implement fallback mechanisms between SendGrid and Nodemailer
   - Log all email activities to the database
   - Use standardized email templates
   - Implement retry logic for failed emails
   - Check for EmailLog model existence before querying

2. **Admin Interface**:
   - Display email logs with filtering options
   - Show statistics for email status distribution
   - Implement pagination for email logs
   - Allow deletion of older logs
   - Provide detailed view for individual emails
   - Handle cases where the EmailLog model doesn't exist yet

### Knowledge GPT

1. **Implementation**:

   - Use Gemini 1.5 Flash-8B for Knowledge GPT
   - Implement web search integration for up-to-date information
   - Support multiple languages
   - Implement domain selection for specialized knowledge
   - Use client-side formatting for responses
   - Provide loading states during generation

2. **UI**:
   - Show chat-like interface for questions and answers
   - Implement language selection dropdown
   - Display web search toggle button
   - Show domain selection for specialized knowledge
   - Provide clear user guidance
   - Ensure responsive design for all devices

### Learning Content Creator

1. **Implementation**:

   - Use GPT-4o-Mini for Learning Creator
   - Support multiple languages
   - Implement structured content generation
   - Store generated content in the database
   - Provide options for content customization
   - Implement retry logic for failed generations

2. **UI**:
   - Show form for topic submission
   - Implement language selection dropdown
   - Display generated content with proper formatting
   - Provide options for content customization
   - Show loading states during generation
   - Ensure responsive design for all devices

### Admin Dashboard

1. **Implementation**:

   - Create responsive admin layout
   - Implement sidebar navigation
   - Show statistics and data visualization
   - Provide filtering and sorting options
   - Implement pagination for large data sets
   - Use try-catch blocks for all database operations
   - Check for table existence before querying
   - Initialize default values for all data variables

2. **UI**:
   - Use card-based layout for statistics
   - Implement responsive design for all screen sizes
   - Show loading states during data fetching
   - Provide clear error messages
   - Use consistent styling across all admin pages
   - Ensure all SelectItem components have non-empty values

## Environment Setup (2025-03-16)

1. **Development Environment**:

   - Node.js 18+
   - npm 9+
   - PostgreSQL 14+
   - Redis (optional)
   - Git

2. **Environment Variables**:

   - `DATABASE_URL`: PostgreSQL connection string
   - `NEXTAUTH_URL`: NextAuth.js URL
   - `NEXTAUTH_SECRET`: NextAuth.js secret
   - `GOOGLE_CLIENT_ID`: Google OAuth client ID
   - `GOOGLE_CLIENT_SECRET`: Google OAuth client secret
   - `SENDGRID_API_KEY`: SendGrid API key
   - `EMAIL_FROM`: Sender email address
   - `SMTP_HOST`: SMTP host for Nodemailer
   - `SMTP_PORT`: SMTP port for Nodemailer
   - `SMTP_USER`: SMTP user for Nodemailer
   - `SMTP_PASSWORD`: SMTP password for Nodemailer
   - `GOOGLE_SEARCH_API_KEY`: Google Custom Search API key
   - `GOOGLE_SEARCH_ENGINE_ID`: Google Custom Search Engine ID
   - `PUBMED_API_KEY`: PubMed API key
   - `GEMINI_API_KEY`: Google Gemini API key
   - `OPENAI_API_KEY`: OpenAI API key

3. **Development Commands**:
   - `npm run dev`: Start development server
   - `npm run build`: Build for production
   - `npm run start`: Start production server
   - `npm run lint`: Run ESLint
   - `npm run test`: Run tests
   - `npx prisma migrate dev`: Run Prisma migrations
   - `npx prisma generate`: Generate Prisma client
   - `npx prisma studio`: Open Prisma Studio

## Recent Learnings (2025-03-16)

1. **Database Error Handling**:

   - Always check for table existence before querying
   - Use `information_schema.tables` to verify table existence
   - Initialize default values for all data variables
   - Use try-catch blocks for all database operations
   - Implement fallbacks for missing or undefined data
   - Add specific error messages for different failure scenarios

2. **Authentication Error Handling**:

   - Use try-catch blocks around authentication checks
   - Initialize session variable as null
   - Use optional chaining for user properties
   - Add null checking for user properties
   - Implement fallbacks for authentication failures
   - Log authentication errors for debugging

3. **UI Component Best Practices**:

   - Ensure all SelectItem components have non-empty values
   - Use "all" instead of empty strings for filter values
   - Update filter logic to handle the "all" value correctly
   - Provide fallback UI states when data is missing
   - Use loading states for async operations
   - Implement error boundaries for critical components

4. **API Route Patterns**:

   - Check for model existence before CRUD operations
   - Use raw SQL queries to verify table existence
   - Implement proper error handling for all API routes
   - Return appropriate HTTP status codes and error messages
   - Use try-catch blocks for all database operations
   - Provide fallback responses when data is missing

5. **Next.js App Router Patterns**:
   - Use server components for data fetching
   - Implement client components for interactive elements
   - Use layout components for shared UI
   - Implement error boundaries for critical sections
   - Use loading states for async operations
   - Handle authentication in layout components

## Troubleshooting Guide (2025-03-16)

1. **Database Connection Issues**:

   - Check DATABASE_URL environment variable
   - Verify PostgreSQL service is running
   - Check network connectivity
   - Verify database user permissions
   - Run `npx prisma migrate dev` to apply migrations
   - Check for missing tables using `information_schema.tables`

2. **Authentication Issues**:

   - Verify NEXTAUTH_URL and NEXTAUTH_SECRET
   - Check Google OAuth credentials
   - Clear browser cookies and try again
   - Verify user roles in the database
   - Check for session expiration
   - Implement try-catch blocks around authentication checks

3. **API Errors**:

   - Check browser console for error messages
   - Verify API route implementation
   - Check for missing environment variables
   - Verify database connection
   - Implement proper error handling
   - Check for model existence before querying

4. **UI Issues**:

   - Check browser console for error messages
   - Verify component props and types
   - Check for missing or undefined data
   - Implement fallback UI states
   - Use error boundaries for critical components
   - Ensure all SelectItem components have non-empty values

5. **Deployment Issues**:
   - Verify environment variables in production
   - Check build logs for errors
   - Verify database connection in production
   - Check for missing dependencies
   - Verify API routes are working
   - Check for CORS issues

## Common Errors and Solutions (2025-03-16)

1. **"Cannot read properties of undefined"**:

   - Initialize default values for all data variables
   - Use optional chaining for potentially undefined properties
   - Add null checking for user properties
   - Implement fallbacks for missing or undefined data
   - Use try-catch blocks for all operations that might fail
   - Check for table existence before querying

2. **"ChunkLoadError: Loading chunk failed"**:

   - Implement proper error handling for all database operations
   - Initialize default values for all data variables
   - Use try-catch blocks for all API calls
   - Provide fallback UI states when data is missing
   - Check for table existence before querying
   - Handle authentication errors gracefully

3. **"Failed to fetch"**:

   - Check network connectivity
   - Verify API route implementation
   - Check for CORS issues
   - Implement retry logic for failed requests
   - Use try-catch blocks for all API calls
   - Provide fallback UI states when data is missing

4. **"Prisma error: Table does not exist"**:

   - Run `npx prisma migrate dev` to apply migrations
   - Check for table existence before querying
   - Use `information_schema.tables` to verify table existence
   - Implement fallbacks for missing tables
   - Use try-catch blocks for all database operations
   - Initialize default values for all data variables

5. **"TypeError: Cannot read property 'map' of undefined"**:
   - Initialize arrays as empty arrays
   - Check if data exists before mapping
   - Use optional chaining for potentially undefined properties
   - Implement fallbacks for missing or undefined data
   - Use try-catch blocks for all operations that might fail
   - Provide default values for all variables

# Cursor Rules

## Redis Monitoring Implementation (March 16, 2025)

### Redis Monitoring API Endpoint

The Redis monitoring API endpoint is implemented in `nextjs-app/src/app/api/monitoring/redis/route.ts`. This endpoint provides metrics about Redis usage, including cache statistics and rate limiting information. Key implementation details:

1. **Error Handling**:

   - The endpoint checks if Redis is configured before attempting to access it
   - Returns a 200 status with error details in the response body instead of a 500 error
   - Uses try-catch blocks around Redis operations to prevent crashes
   - Makes authorization optional in development environment

2. **Data Type Handling**:

   - Checks if data is already an object before attempting to parse it as JSON
   - Uses type guards to prevent "not valid JSON" errors
   - Handles both string and object data types appropriately

3. **Rate Limiting**:

   - Uses Upstash Ratelimit library with string format for duration (e.g., "60 s")
   - Implements error handling for rate limiting failures
   - Allows the application to continue functioning even if rate limiting fails

4. **Metrics Collection**:

   - Gathers metrics from redisMonitor, redisCache, and rateLimit services
   - Calculates cache hit rates and other performance metrics
   - Provides reset functionality for metrics, cache, and rate limits

5. **Response Format**:
   - Returns a standardized response format with success status and data
   - Includes error details when operations fail
   - Provides comprehensive monitoring data for the admin dashboard

### Redis Monitoring Component

The Redis monitoring component is implemented in `nextjs-app/src/components/admin/RedisMonitoring.tsx`. Key implementation details:

1. **Error Handling**:

   - Uses optional chaining to handle null or undefined values
   - Provides fallback UI when Redis is not configured
   - Displays error messages when operations fail

2. **UI Features**:

   - Displays cache hit rates and other performance metrics
   - Provides buttons to reset metrics, cache, and rate limits
   - Uses responsive design for mobile compatibility

3. **Data Fetching**:
   - Implements polling to update metrics at regular intervals
   - Handles loading and error states appropriately
   - Uses SWR for data fetching with automatic revalidation

### Rate Limiting Implementation

The rate limiting implementation is in `nextjs-app/src/lib/rate-limit.ts`. Key implementation details:

1. **Configuration**:

   - Uses Upstash Ratelimit library for Redis-based rate limiting
   - Configures sliding window duration using string format (e.g., "60 s")
   - Implements error tracking and monitoring

2. **Error Handling**:

   - Uses try-catch blocks to handle rate limiting failures
   - Provides fallback behavior when rate limiting fails
   - Logs errors for monitoring and debugging

3. **Integration**:
   - Integrates with the monitoring system to provide rate limiting metrics
   - Supports reset functionality for rate limits
   - Configurable limits based on environment and endpoint

## NextJS 15 Dynamic Route Parameters (March 16, 2025)

In Next.js 15, dynamic route parameters are now asynchronous and must be awaited before use. This is a breaking change from previous versions.

### Correct Pattern for API Routes

```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  // Await the params object to get the id
  const { id } = await params;

  // Use the id parameter
  // ...
}
```

### Common Errors

- Using `params.id` directly without awaiting params first
- Not typing params as a Promise
- Not destructuring the id after awaiting params

### Best Practices

- Always type params as `Promise<{ paramName: string }>`
- Always await params before accessing its properties
- Use destructuring to extract parameters after awaiting
- Add proper error handling for asynchronous operations

## Redis Rate Limiting (March 16, 2025)

When using Upstash Redis for rate limiting, use the string format for duration:

```typescript
const limiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(limit, `${windowInSeconds} s`),
  analytics: true,
  prefix: `rate_limit_${endpoint}`,
});
```

## Admin Dashboard Error Handling (March 16, 2025)

- Always add try-catch blocks for all API calls
- Provide fallback values when data is missing or undefined
- Check for database table existence before querying
- Initialize default values for all data variables
- Use optional chaining for potentially null values
- Return 200 status with error details instead of 500 errors

## UI Component Rules (March 16, 2025)

- Ensure all SelectItem components have non-empty values (use "all" instead of empty string)
- Provide fallback UI states when data is missing or loading
- Ensure consistent button heights and alignment
- Use responsive design for all components, especially admin interfaces

# Newsletter Subscription System (March 16, 2025)

When working with the newsletter subscription system, ensure:

1. Use the correct model name `newsletterSubscriber` (not `newsletter`) in all API routes
2. In development mode with MOCK_NEWSLETTER=true, create real database entries for testing
3. Handle both pending and confirmed states properly
4. Implement proper error handling for database operations
5. Use proper logging for subscription and confirmation processes

## Development Mode Testing

When testing in development mode:

- Set MOCK_NEWSLETTER=true in .env
- Create real subscribers in the database for testing
- Use pending status during subscription
- Update to confirmed status during confirmation
- Ensure subscribers appear in the admin dashboard

## Newsletter Subscriber Model

The newsletter subscriber model has the following fields:

- id: string (cuid)
- email: string (unique)
- name: string (optional)
- tags: string[]
- confirmed: boolean
- confirmedAt: DateTime (optional)
- status: string (pending, confirmed, unsubscribed)
- token: string (for confirmation)
- tokenExpiry: DateTime
- source: string (optional)

## NextJS 15 Dynamic Route Parameters (March 16, 2025)

In Next.js 15, dynamic route parameters are now asynchronous and must be awaited before use. This is a breaking change from previous versions.

### Correct Pattern for API Routes

```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  // Await the params object to get the id
  const { id } = await params;

  // Use the id parameter
  // ...
}
```

### Common Errors

- Using `params.id` directly without awaiting params first
- Not typing params as a Promise
- Not destructuring the id after awaiting params

### Best Practices

- Always type params as `Promise<{ paramName: string }>`
- Always await params before accessing its properties
- Use destructuring to extract parameters after awaiting
- Add proper error handling for asynchronous operations

## Redis Rate Limiting (March 16, 2025)

When using Upstash Redis for rate limiting, use the string format for duration:

```typescript
const limiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(limit, `${windowInSeconds} s`),
  analytics: true,
  prefix: `rate_limit_${endpoint}`,
});
```

## Admin Dashboard Error Handling (March 16, 2025)

- Always add try-catch blocks for all API calls
- Provide fallback values when data is missing or undefined
- Check for database table existence before querying
- Initialize default values for all data variables
- Use optional chaining for potentially null values
- Return 200 status with error details instead of 500 errors

## UI Component Rules (March 16, 2025)

- Ensure all SelectItem components have non-empty values (use "all" instead of empty string)
- Provide fallback UI states when data is missing or loading
- Ensure consistent button heights and alignment
- Use responsive design for all components, especially admin interfaces

## React Error Handling Pattern for Asynchronously Loaded Data (March 16, 2025)

When working with asynchronously loaded data in React components, it's important to implement proper error handling to prevent "Cannot read properties of undefined" errors. Here's the pattern we've established:

1. **Conditional Rendering**: Always wrap UI elements that depend on asynchronously loaded data in conditional checks.

```jsx
{
  historyPagination && (
    <div className="pagination-controls">
      {/* Pagination controls that use historyPagination */}
    </div>
  );
}
```

2. **Default Values**: Initialize state variables with sensible default values that match the expected structure.

```jsx
const [historyPagination, setHistoryPagination] = useState({
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 1,
});
```

3. **Optional Chaining and Nullish Coalescing**: Use optional chaining and nullish coalescing operators to handle potentially undefined values.

```jsx
<span>{historyPagination?.totalPages || 1}</span>
```

4. **API Response Structure**: Ensure API response structures match frontend expectations. When modifying API responses, update all places where the data is used.

```jsx
// API response
return NextResponse.json({
  history: formattedHistory,
  pagination: {
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
  },
});

// Frontend usage
setHistory(data.history);
setHistoryPagination(data.pagination);
```

5. **Error Handling in API Calls**: Implement try-catch blocks for all API calls with appropriate fallbacks.

```jsx
try {
  const response = await fetch("/api/endpoint");
  const data = await response.json();
  // Process data
} catch (error) {
  console.error("Error fetching data:", error);
  // Set default values or show error message
} finally {
  // Clean up (e.g., set loading state to false)
}
```

This pattern helps prevent runtime errors and provides a better user experience by gracefully handling cases where data might not be available yet.

## Admin Layout Improvements - March 16, 2025

The admin layout has been improved to fix issues with the sidebar and main content:

1. **Layout Structure**:

   - Changed from a relative positioning approach to a flex-based layout
   - Used `flex min-h-screen` on the root container to ensure proper height
   - Made the main content area use `flex-1 flex flex-col` for proper spacing

2. **Sidebar Improvements**:

   - Fixed the sidebar to prevent overlap with main content
   - Added a close button in the sidebar for better mobile usability
   - Made the sidebar use `lg:relative` instead of `lg:static` for better positioning
   - Ensured consistent width and spacing in the sidebar

3. **Navigation Bar**:

   - Made the top navigation bar sticky with `sticky top-0` for better navigation on long pages
   - Improved the mobile toggle button placement and visibility
   - Added proper spacing between navigation elements

4. **Mobile Responsiveness**:

   - Improved sidebar toggle controls for mobile devices
   - Added proper z-index management to ensure UI elements don't overlap
   - Ensured the sidebar overlay properly covers the entire screen on mobile
   - Made the sidebar close when clicking outside or on a navigation link

5. **Content Area**:
   - Added proper padding and margin to the main content area
   - Ensured consistent spacing between elements
   - Added `mt-4` to the main content to separate it from the breadcrumb

These improvements ensure a consistent and responsive admin dashboard experience across all device sizes.

## API Endpoint Patterns - [2025-03-17 10:15:00]

### Prisma Query Best Practices - [2025-03-17 10:15:00]

- Avoid using raw SQL queries with `prisma.$queryRaw` when possible
- Prefer standard Prisma query methods like `findMany`, `findUnique`, `update`, etc.
- Raw SQL queries can cause serialization issues with BigInt values and other complex types
- When transforming data from Prisma queries, use proper type safety:
  ```typescript
  // Transform the data to include additional properties
  const transformedData = data.map((item) => ({
    ...item,
    computedProperty: calculateValue(item),
    // Remove properties that shouldn't be sent to the client
    sensitiveData: undefined,
  }));
  ```
- Always handle potential null or undefined values in query results
- Use proper error handling with try/catch blocks for all database operations

### API Error Handling - [2025-03-17 10:15:00]

- Implement consistent error handling across all API endpoints
- Use try/catch blocks to catch and properly handle errors
- Log errors with appropriate context for debugging
- Return standardized error responses with meaningful messages
- Example pattern:
  ```typescript
  try {
    // Database operations or other code that might throw
    const result = await prisma.someModel.findMany();
    return NextResponse.json({ data: result });
  } catch (error) {
    console.error("Error description:", error);
    return NextResponse.json(
      { error: "User-friendly error message" },
      { status: 500 }
    );
  }
  ```

## Email Integration Patterns - [2025-03-17 10:15:00]

### SendGrid Inbound Parse Configuration - [2025-03-17 10:15:00]

- SendGrid Inbound Parse is used to process incoming emails
- Configuration requirements:
  1. Set up MX records for the domain to point to SendGrid's inbound mail servers
  2. Configure SendGrid Inbound Parse to forward emails to the webhook URL: `/api/webhooks/inbound-email`
  3. Ensure the webhook endpoint can handle the specific JSON format sent by SendGrid
- The webhook handler expects specific fields from SendGrid:
  - `from` or `sender` or `email` for the sender's email address
  - `subject` for the email subject
  - `text` or `plain` or `content` for the plain text content
  - `html` or `html_content` for the HTML content
- Incoming emails are stored in the `InboundEmail` model and processed to create contact submissions or replies

### Email Processing Workflow - [2025-03-17 10:15:00]

- Incoming emails follow this processing flow:
  1. Email is received by SendGrid's inbound mail servers
  2. SendGrid forwards the email to the webhook endpoint
  3. The webhook handler stores the raw email in the `InboundEmail` model
  4. The `processInboundEmail` function analyzes the email to determine if it's a new submission or a reply
  5. If it's a reply (contains a reference code), it's linked to the existing submission
  6. If it's a new submission, a new contact submission is created
- Reference codes are used to track email threads:
  - Format: `REF-[submissionId]-[timestamp]`
  - Example: `REF-abc123-20250317101500`
  - These are included in the subject line of outgoing emails
  - When replies are received, the reference code is extracted to link the reply to the original submission
