# Project Intelligence - [2025-03-11 15:06:15]

## Core Development Patterns

### Project Structure and Configuration - [2025-03-11 15:06:15]

- Development folder: `/nextjs-app`
- Git directory: root folder `/synthalyst`
- Project guides: `/guides`
- Development server runs on port 3001
- All development must be focused in the `/nextjs-app` directory
- Never install packages in the root folder
- Always check folder before installing any package
- Update memory bank before staging files
- Stage and commit files from the root directory
- Always stage files with `git add .`

### Next.js App Router Conventions - [2025-03-11 15:06:15]

- Each route requires its own directory (e.g., `/about`, `/services`, `/contact`)
- The actual page component must be named `page.tsx` inside that directory
- Example structure:
  ```
  src/app/
  ├── about/
  │   └── page.tsx
  ├── services/
  │   └── page.tsx
  ├── contact/
  │   └── page.tsx
  ```
- Do not use flat files like `about.tsx` directly in the app directory
- Layouts can be defined using `layout.tsx` files in the appropriate directories
- Route groups can be created using parentheses in directory names: `(auth)/login`
- Dynamic routes use square brackets: `[slug]/page.tsx`
- Catch-all routes use triple dots: `[...slug]/page.tsx`
- Optional catch-all routes use double square brackets: `[[...slug]]/page.tsx`

### Client vs Server Components - [2025-03-11 15:06:15]

- All components are Server Components by default
- Add "use client" directive at the top of the file to make it a Client Component
- Client Components are needed for:
  - Interactive features (forms, buttons, etc.)
  - Browser APIs (localStorage, navigator, etc.)
  - React hooks (useState, useEffect, etc.)
  - Event handlers (onClick, onError, etc.)
- Server Components are better for:
  - Fetching data
  - Accessing backend resources directly
  - Keeping sensitive information on the server
  - Reducing client-side JavaScript

### Event Handlers in Server Components - [2025-03-11 15:06:15]

- Event handlers cannot be passed to Client Component props from Server Components
- Error: "Event handlers cannot be passed to Client Component props"
- Common event handlers that require Client Components:
  - onClick
  - onChange
  - onSubmit
  - onError
  - onLoad
  - onFocus
  - onBlur
- Solutions:
  1. Convert the component to a Client Component by adding "use client" directive
  2. Move the event handler to a separate Client Component
  3. Use a different approach that doesn't require event handlers

### ClientComponentWrapper Pattern - [2025-03-11 15:06:15]

- Use the ClientComponentWrapper for client components that use Next.js navigation hooks
- Provides a consistent Suspense boundary for client components
- Implements a standardized loading UI with spinner and customizable text
- Simplifies the implementation of proper Suspense boundaries
- Available variants:
  - Default: Centered spinner with text
  - Minimal: Inline spinner with small text
  - Fullscreen: Overlay with backdrop blur
  - Skeleton: Content placeholder
- Higher-Order Component (HOC) version available for a more functional approach
- Use for any client component that uses:
  - useSearchParams()
  - usePathname()
  - useRouter()

### Next.js 15 Type Requirements - [2025-03-11 15:06:15]

- In Next.js 15, route handlers and page components with dynamic route parameters must have specific type requirements:
- Route Handler Parameters:
  ```typescript
  export async function GET(
    req: Request,
    { params }: { params: Promise<{ id: string }> }
  ) {
    const { id } = await params;
    // Use id here
  }
  ```
- Page Component Parameters:

  ```typescript
  interface PageProps {
    params: Promise<{ id: string }>;
  }

  export default async function Page(props: PageProps) {
    const params = await props.params;
    const { id } = params;
    // Use id here
  }
  ```

- Always await the params object before accessing its properties
- When working with LLM responses, always add null checks to prevent potential null reference errors:
  ```typescript
  const responseContent = completion.choices[0].message.content as string;
  const generatedContent = JSON.parse(responseContent || "{}");
  ```

## UI and Component Patterns

### Component Architecture - [2025-03-11 15:06:15]

- The application uses a component-based architecture with shadcn UI components as the foundation
- All shadcn UI components are located in `@/components/ui/`
- Components follow a consistent pattern with proper TypeScript typing
- Tailwind animations and keyframes are centralized in the tailwind.config.ts file with no duplications
- Component organization:
  - **Feature-specific Components**: Located in `src/app/[feature]/components/`
  - **Shared Components**: Located in `src/components/`
    - `ui/`: Basic UI components (buttons, inputs, etc.)
    - `layout/`: Layout components (Header, Footer, etc.)
    - `shared/`: Other shared components used across features
  - **Import Pattern**:
    - Use `@/` path alias for imports from src directory
    - Example: `import { Button } from "@/components/ui/button"`
    - Feature-specific imports use relative paths

### Toast System - [2025-03-11 15:06:15]

- The project uses the sonner toast system
- Always import toast from `@/lib/toast-migration` instead of `@/hooks/use-toast`
- Example usage:

  ```typescript
  import { toast } from "@/lib/toast-migration";

  // Success toast
  toast({
    title: "Success",
    description: "Operation completed successfully.",
  });

  // Error toast
  toast({
    variant: "destructive",
    title: "Error",
    description: "Something went wrong.",
  });
  ```

- The main Toaster component is imported from our custom UI component:
  - `import { Toaster } from "@/components/ui/sonner";`
  - This is ONLY used in the root layout.tsx file
  - DO NOT add Toaster components to individual pages

### TooltipProvider Usage Pattern - [2025-03-11 15:06:15]

- Always wrap components that use tooltips with a TooltipProvider
- Prefer wrapping the entire component with a single TooltipProvider at the top level
- Avoid nesting TooltipProviders as this can cause CSS issues and UI breakage
- When using tooltips in a component, ensure the following structure:
  ```tsx
  <TooltipProvider>
    <Tooltip>
      <TooltipTrigger>
        <InfoIcon className="h-4 w-4 ml-1 text-gray-400" />
      </TooltipTrigger>
      <TooltipContent>
        <p className="max-w-xs">Tooltip content here</p>
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
  ```
- If you have multiple tooltips in a component, wrap the entire component with a single TooltipProvider

### Component Variants - [2025-03-11 15:06:15]

- The Card component has been extended with a gradient variant:
  ```tsx
  <Card variant="gradient" variantKey="primary">
    <CardHeader>
      <CardTitle>Card Title</CardTitle>
    </CardHeader>
    <CardContent>
      <p>Card content</p>
    </CardContent>
  </Card>
  ```
- Available gradient keys:
  - `primary`: Blue to indigo gradient
  - `secondary`: Purple to pink gradient
  - `accent`: Amber gradient
  - `info`: Subtle blue gradient
  - `default`: Subtle gray gradient

### UI Animation Guidelines - [2025-03-11 15:06:15]

- Animations should be subtle and professional, not flashy or distracting
- Use longer intervals (3+ seconds) between animation changes
- Choose color schemes that align with the brand identity (blues, blacks)
- Implement proper cleanup to prevent memory leaks
- Use React's useId() hook for stable IDs in SVG elements
- Add aria-labels to animated elements for accessibility
- Test animations on both high and low-end devices to ensure performance

### Responsive Design Patterns - [2025-03-11 15:06:15]

- Start with a minimal, functional mobile design
- Add features and complexity for larger screens
- Use Tailwind's responsive prefixes (sm:, md:, lg:, xl:) to control visibility
- Hide descriptive text on small screens with `hidden md:inline-block`
- Show only essential icons/badges on mobile
- Maintain touch-friendly tap targets (min 44px) on all screen sizes
- Use flex-wrap for horizontal elements that might overflow
- Implement grid layouts with auto-fit/auto-fill for dynamic columns
- Set appropriate min/max widths to prevent extreme scaling
- Use responsive spacing utilities (p-2 sm:p-4 md:p-6)
- Maintain adequate whitespace on all screen sizes
- Reduce padding/margins proportionally on smaller screens
- Test at standard breakpoints: 640px, 768px, 1024px, 1280px

## LLM Integration Patterns

### AI Excellence Focus - [2025-03-11 15:06:15]

- The primary goal of all development is to make LLMs and AI agents shine in user interactions
- Every feature should be designed to showcase the intelligence of the AI
- Prioritize quality of AI outputs over quantity of features
- Key principles to follow:
  1. Craft sophisticated prompts that bring out the best in LLMs
  2. Implement post-processing to ensure professional formatting of AI outputs
  3. Design features that maintain context between user interactions
  4. Personalize AI responses based on user needs and preferences
  5. Continuously refine AI implementations based on user feedback

### LLM Implementation Best Practices - [2025-03-11 15:06:15]

- Always use the most appropriate model for each task:
  - Use Gemini 2.0 Flash for quick, responsive interactions
  - Use GPT-4 for complex reasoning and creative tasks
  - Use specialized models for specific domains when appropriate
- Implement robust error handling for AI interactions:
  - Gracefully handle API failures
  - Provide meaningful fallbacks when AI services are unavailable
  - Implement retry logic with exponential backoff
- Optimize prompts for each model's strengths and limitations
- Test AI outputs extensively with diverse inputs
- Monitor and log AI performance metrics to identify areas for improvement
- Regularly review and update prompts based on output quality

### Gemini Model Usage Pattern - [2025-03-11 15:06:15]

- Always use the centralized `getGeminiModel()` function from `nextjs-app/src/lib/gemini.ts` to access the Gemini model
- Never hardcode the model name in individual components or API routes
- The current model version is "gemini-2.0-flash-001"
- Environment variable: `GEMINI_API_KEY` (server-side only)
- Example usage:

  ```typescript
  import { getGeminiModel } from "@/lib/gemini";

  const generateContent = async (prompt: string) => {
    try {
      const model = getGeminiModel();
      const result = await model.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error("Error generating content with Gemini:", error);
      throw error;
    }
  };
  ```

### OpenRouter API Integration - [2025-03-11 15:06:15]

- The OpenRouter API is used for accessing the Llama 3.2 3b model in the Training Plan Creator
- Always use the `openRouter` instance from `@/lib/openrouter` for OpenRouter API calls
- The model name is "meta-llama/llama-3.2-3b-instruct"
- Environment variable: `OPENROUTER_API_KEY`
- Implementation in `nextjs-app/src/lib/openrouter.ts` and `nextjs-app/src/lib/llama.ts`
- Example usage:

  ```typescript
  import { openRouter } from "@/lib/openrouter";

  // Call OpenRouter with Llama 3.2 3b
  const response = await openRouter.chat.completions.create({
    model: "meta-llama/llama-3.2-3b-instruct",
    messages: [
      { role: "system", content: systemMessage },
      { role: "user", content: prompt },
    ],
    temperature: 0.7,
    max_tokens: 3500,
  });
  ```

### Two-Stage LLM Approach - [2025-03-11 15:06:15]

- The Training Plan Creator uses a two-stage approach for premium users:
  1. Gemini 2.0 Flash for resource recommendations
  2. Llama 3.2 3b for plan generation
- For free users, only the Llama 3.2 3b model is used with an enhanced prompt
- This approach ensures premium users get high-quality, current resources while maintaining good plan generation for all users
- Implementation in `nextjs-app/src/app/api/training-plan/enhanced-generate/route.ts`

### Structured Text Response Pattern - [2025-03-11 15:06:15]

- When working with LLM responses that need to be parsed into structured data, prefer using clear section headers over JSON
- Benefits of section-based extraction:
  - More reliable parsing with less complex code
  - Easier to debug and maintain
  - Less prone to JSON formatting errors from the LLM
  - Simpler extraction logic
- Implementation pattern:
  1. In the prompt, specify exact section headers (e.g., "QUESTIONS:", "EVALUATION TIPS:")
  2. Request numbered items within each section for easier parsing
  3. Use regex to extract content between section headers
  4. Process each section's content separately
- Example prompt structure:

  ```
  Format your response as follows:

  SECTION_1:
  1. First item
  2. Second item
  ...

  SECTION_2:
  1. First item
  2. Second item
  ...
  ```

- Always include fallback mechanisms for when the LLM doesn't follow the format exactly
- For HTML content, use simple text-to-HTML conversion rather than asking the LLM to generate HTML directly

### LLM Quality Control Patterns - [2025-03-11 15:06:15]

- When implementing LLM-based features, always include comprehensive quality control measures:
  1. **Enhanced Prompting**:
     - Use detailed system prompts with specific instructions
     - Include examples of desired output format and quality
     - Specify requirements for structure, completeness, and relevance
  2. **Parameter Tuning**:
     - Use lower temperature (0.5-0.7) for more consistent outputs
     - Adjust max_tokens based on the expected response length
     - Consider using top_p and frequency_penalty for diverse but controlled outputs
  3. **Output Validation**:
     - Implement comprehensive quality checks for LLM outputs
     - Validate minimum length, structure, and completeness
     - Check for presence of key terms relevant to the domain
     - Ensure proper sentence structure and punctuation
  4. **Fallback Mechanisms**:
     - Create high-quality fallback content for when LLM generation fails
     - Make fallbacks context-aware using user input parameters
     - Ensure fallbacks maintain the same structure and format as expected LLM outputs
  5. **Model Selection**:
     - Use smaller, more reliable models when possible
     - Implement model fallback chains (e.g., Llama → Gemini)
     - Balance performance with reliability based on the use case

### Feedback Collection Patterns - [2025-03-11 15:06:15]

- Every AI-powered tool should include at least one feedback mechanism
- Types of feedback mechanisms to implement:
  - Simple rating systems (1-5 stars, thumbs up/down)
  - Detailed feedback forms for specific aspects of AI output
  - In-context feedback options during tool usage
  - Follow-up emails requesting feedback after tool usage
- Best practices for feedback implementation:
  - Keep primary feedback mechanisms simple and non-intrusive
  - Offer more detailed feedback options as a secondary step
  - Clearly explain how feedback improves the AI
  - Thank users for providing feedback
  - Show appreciation for detailed feedback

## Testing Patterns

### Component Test Structure - [2025-03-11 15:06:15]

```typescript
// Always follow this structure for component tests
describe("ComponentName", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset any global mocks
  });

  it("renders required elements", () => {
    // Test basic rendering
  });

  it("handles user interactions", async () => {
    // Test user interactions
  });

  it("handles API interactions", async () => {
    // Test API calls
  });

  it("handles error cases", async () => {
    // Test error scenarios
  });
});
```

### Mock Component Patterns - [2025-03-11 15:06:15]

```typescript
// Pattern for mocking form components
jest.mock("@/components/ui/form", () => ({
  Form: ({ children }) => <div>{children}</div>,
  FormField: ({ render, name }) =>
    render({
      field: { value: "", onChange: jest.fn(), name },
    }),
  // ... other form components
}));

// Pattern for mocking select components
jest.mock("@/components/ui/select", () => ({
  Select: ({ children, name, ...props }) => (
    <select role="combobox" aria-label={name} title={name} {...props}>
      {children}
    </select>
  ),
  // ... other select components
}));
```

### API Test Structure - [2025-03-11 15:06:15]

1. Test successful API calls:
   - Mock successful responses
   - Verify response status and body
   - Verify API was called with correct parameters
2. Test validation errors:
   - Test with invalid or missing parameters
   - Verify 400 status code
   - Verify error messages
3. Test API errors:
   - Mock API failures
   - Verify proper error handling
   - Verify 500 status code
4. Test edge cases:
   - Empty responses
   - Malformed responses
   - Missing API keys

### Mock Prisma Client Pattern - [2025-03-11 15:06:15]

The project uses a standardized approach for mocking the Prisma client in API tests. This pattern is implemented in `nextjs-app/src/lib/test/prisma-mock.ts` and should be followed for all API tests.

Key components:

1. **TypeScript Interfaces**: Define interfaces for all mock storage objects to ensure type safety.
2. **Mock Implementation**: Create a mock implementation that mimics the Prisma client's behavior.
3. **Error Handling**: Implement consistent error handling across all mock methods.
4. **Test Setup**: Use the mock in tests by accessing the global mock instance.
5. **Creating Test Data**: Create test data using the mock Prisma client.
6. **Handling Relationships**: For many-to-many relationships, directly update the storage.
7. **API Route Params**: When testing API routes, use the correct pattern for params.
8. **Verifying Results**: Verify the results of API calls.

## Form Patterns

### Form Implementation - [2025-03-11 15:06:15]

1. Use React Hook Form for form state management
2. Use Zod for schema validation
3. Use Radix UI components for accessibility
4. Use toast notifications for feedback

### Form Validation - [2025-03-11 15:06:15]

1. Required fields:
   - Minimum length validation
   - Custom error messages
2. Optional fields:
   - Clear validation rules
   - Default values
3. Select fields:
   - Predefined options
   - Default selection

### Form Submission - [2025-03-11 15:06:15]

1. Loading state management
2. Error handling
3. Success feedback
4. Form reset
5. Data transformation

### Form Field Structure - [2025-03-11 15:06:15]

```typescript
<FormField
  control={form.control}
  name="fieldName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Label</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormDescription>Helper text</FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Error Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  // API call
  const response = await fetch("/api/endpoint");
  if (!response.ok) {
    throw new Error("API Error");
  }
  // Success handling
  toast({
    title: "Success",
    description: "Operation completed successfully",
  });
} catch (error) {
  // Error handling
  toast({
    title: "Error",
    description: "Operation failed. Please try again.",
    variant: "destructive",
  });
}
```

### API Response Handling Pattern - [2025-03-11 15:06:15]

```typescript
try {
  const response = await fetch("/api/endpoint", {
    method: "METHOD",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  });

  // Parse the response data first
  let data;
  try {
    data = await response.json();
  } catch (parseError) {
    console.error("Error parsing response:", parseError);
    data = { fallbackData: true };
  }

  // Then check if the response is OK
  if (!response.ok) {
    throw new Error(data.error || "Default error message");
  }

  // Use the parsed data
  return data;
} catch (error) {
  console.error("Error:", error);
  // Handle the error appropriately
}
```

## Authentication and Authorization

### Authentication System - [2025-03-11 15:06:15]

- The application uses NextAuth.js for authentication with the following features:
  - Credentials provider (email/password)
  - Google OAuth provider
- Configuration in `nextjs-app/src/app/api/auth/[...nextauth]/auth.ts`
- Environment variables:
  ```
  NEXTAUTH_URL=http://localhost:3000
  NEXTAUTH_SECRET=your-secret-here
  GOOGLE_CLIENT_ID=your-google-client-id
  GOOGLE_CLIENT_SECRET=your-google-client-secret
  ```
- Authentication pages:
  - Sign-in page: `nextjs-app/src/app/auth/signin/page.tsx`
  - Sign-up page: `nextjs-app/src/app/auth/signup/page.tsx`
- Session management:
  - JWT strategy for session tokens
  - Session data stored in cookies
  - Session expiration configurable in NextAuth options

### Role-Based Access Control - [2025-03-11 15:06:15]

- Three-tier role system:
  - Superadmin (pgtipping1@gmail.com)
  - Admin
  - User
- Role hierarchy enforced through multiple layers:
  - API route authorization
  - Client-side component protection
  - Server-side session validation
- Role checks in API routes with proper error handling
- Protected routes with client-side redirects
- Real-time role updates with optimistic UI
- Exclusive superadmin privileges for role modification
- Protected superadmin account from role changes
- Role update API with proper validation
- Real-time UI feedback for role changes

## Feature-Specific Patterns

### Blog Post Creation Pattern - [2025-03-11 15:06:15]

- Blog posts can be created through two methods:
  1. Direct API method (Preferred):
     - Use `/api/posts` endpoint for database-driven posts
     - Use `/api/blog/generate` for LLM-assisted content creation
     - No filesystem operations required
     - Works consistently across all environments
  2. MDX file method (Legacy/Optional):
     - Store MDX files in filesystem
     - Requires manual file syncing across environments
     - More complex to maintain
     - Can cause deployment issues
- Key principles to follow:
  1. Prefer direct API method for new blog posts
  2. Use LLM assistance for professional content generation
  3. Store all content in database for consistency
  4. Avoid filesystem-based content when possible

### Blog Post Layout Pattern - [2025-03-11 15:06:15]

- Blog post content should use a constrained width to improve readability:
  ```jsx
  <article className="prose prose-lg max-w-4xl mx-auto">
    {/* Blog post content */}
  </article>
  ```
- Use black text for paragraph content to ensure readability
- Use Radix UI icons for a professional and consistent look
- Key aspects of this pattern:
  - Use `max-w-4xl` for blog post content to match comment section width
  - Avoid using `max-w-none` which would override parent width constraints
  - Center content with `mx-auto` for balanced white space on both sides
  - Maintain consistent width between article content and comments section
  - This width provides optimal readability while adding sufficient white space

### JD Developer Form Validation - [2025-03-11 15:06:15]

- The JD Developer form has been updated to make education, experience, and certifications optional. The only mandatory fields for generating job descriptions are:
  - Job title
  - Employment type
  - Position level
  - Industry
- The API validation schema in `nextjs-app/src/app/api/jd-developer/generate/route.ts` has been modified to make these fields optional by using `.default([])` instead of `.min(1, "...")`.
- The POST function has also been updated to ensure that all arrays are properly passed to the `generateJobDescription` function, even if they're not provided in the request.
- The UI already correctly labels these fields as optional:
  - Educational Requirements (Optional)
  - Professional Experience (Optional)
  - Required Certifications (Optional)

### Template Filtering Pattern - [2025-03-11 15:06:15]

- Templates are stored in the same database table as regular job descriptions
- Templates are identified by the `isTemplate` flag in the metadata
- Two-layer filtering approach is used to ensure proper separation:
  1. Database query filtering: `content: { not: { contains: '"isTemplate":true' } }`
  2. Parsed content verification: `if (parsedContent.metadata?.isTemplate === true) { return null; }`
- This double-checking approach ensures templates only appear in the templates list
- Always filter out null entries after parsing: `.filter(Boolean)`
- Handle JSON parsing errors gracefully with try/catch blocks
- Log parsing errors for debugging: `console.error(`Error parsing JD ${jd.id}:`, error);`

### Newsletter System Patterns - [2025-03-11 15:06:15]

- All newsletter routes must be under `/api/admin/newsletter/`
- All routes require admin role authentication
- Use Prisma's type-safe query builder
- Implement comprehensive error handling
- Return consistent response formats
- Database Models:
  - NewsletterSubscriber: Manages subscriber data and status
  - NewsletterTemplate: Stores reusable email templates
  - NewsletterSend: Tracks newsletter sending history
  - NewsletterReply: Handles subscriber responses
- Field Naming Conventions:
  - Use `createdAt` for creation timestamps
  - Use `updatedAt` for modification timestamps
  - Use descriptive names for status fields
  - Maintain consistent field names across models

## Development Workflow

### Command Execution Safety - [2025-03-11 15:06:15]

1. ALWAYS verify current directory before running any commands
2. Use `list_dir` to check directory structure
3. Navigate to correct directory if needed
4. Verify package.json exists in current directory before running npm commands
5. Document directory context in explanations
6. ALWAYS add a space before ALL terminal commands to ensure proper history tracking and prevent typo errors
   - Example: ` ls -la` instead of `ls -la`
   - Example: ` git status` instead of `git status`
   - Example: ` cd src` instead of `cd src`
   - This applies to all commands: ` npm`, ` git`, ` ls`, ` cd`, etc.

### Git Commit Approach - [2025-03-11 15:06:15]

- When committing changes to the repository, always use `git add .` instead of specifying individual file paths
- The correct approach for committing changes is:

  ```bash
  # Stage all changes
  git add .

  # Commit with a descriptive message
  git commit -m "Descriptive message about the changes"
  ```

- Git Commit Messages:
  - feat: New features
  - fix: Bug fixes
  - test: Test changes
  - docs: Documentation
  - refactor: Code improvements
  - style: Formatting changes

### Memory Bank Update Pattern - [2025-03-11 15:06:15]

- ALWAYS programmatically determine today's date when updating memory bank files
- Never use hardcoded dates in memory bank entries
- Use the following pattern to get the current date in YYYY-MM-DD format:
  ```bash
  # In terminal
  date +"%Y-%m-%d"
  ```
  ```javascript
  // In JavaScript
  const today = new Date().toISOString().split("T")[0];
  ```
- Apply the current date to all new entries in memory bank files:
  - Use the date for section headings: `## Current Focus (YYYY-MM-DD)`
  - Use the date for entry timestamps: `- ✅ UPDATED: Feature X (YYYY-MM-DD)`
  - Use the date for file headings: `# Progress Report - YYYY-MM-DD`

### Environment Configuration Pattern - [2025-03-11 15:06:15]

- Local Development:
  - `.env` file contains development configuration
  - Variables are commented with explanations
  - Duplicate entries are avoided
- Production:
  - Production values should be set in the deployment platform (Vercel)
  - Alternative: use `.env.production` for production values
  - Comments indicate which values to use in production
- Critical Variables:
  - `NEXTAUTH_URL`: The base URL of the application
  - `NEXTAUTH_SECRET`: Secret for NextAuth session encryption
  - `DATABASE_URL`: Connection string for the database
  - `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: Google OAuth credentials
  - `GEMINI_API_KEY`: API key for Gemini LLM
  - `OPENROUTER_API_KEY`: API key for OpenRouter (Llama model)

### Sensitive Information Handling - [2025-03-11 15:06:15]

- NEVER commit .env files to the repository
- The .env file should be listed in .gitignore
- Use .env.example to document required environment variables without actual values
- If .env is accidentally committed, it must be removed from the entire git history
- GitHub has push protection that blocks commits containing secrets
- If a push is rejected due to containing secrets, you must remove the secrets from the git history
- Never use the GitHub option to allow the secret, as this is a security risk

# ApplyRight Feature Implementation - June 14, 2023

## Document Parsing Strategy - [2023-06-14]

When implementing document parsing for the ApplyRight feature, we initially encountered issues with PDF.js integration. The PDF.js library required specific configuration to work properly in a Next.js environment, particularly with its worker files.

### Initial PDF.js Integration Issues

The main issue was that the PDF.js worker file couldn't be found during the build process, resulting in the error:

```
Error: ENOENT: no such file or directory, open 'C:\Users\pgeor\OneDrive\Documents\Web Dev\synthalyst\nextjs-app\node_modules\pdfjs-dist\build\pdf.js'
```

### Solution: Client-Side Only PDF Parsing

After researching alternatives, we implemented PDF support using the react-pdftotext package with dynamic imports to ensure it only runs on the client side. This approach avoids server-side rendering issues with the PDF.js dependency.

Key benefits of this approach:

1. Avoids server-side rendering issues with PDF.js
2. Uses dynamic imports to load the PDF parser only when needed
3. Provides a clean fallback for server-side rendering
4. Works well with Next.js without complex configuration
5. Memory-safe implementation

Implementation:

```typescript
async function parsePdf(file: File): Promise<string> {
  try {
    // Dynamically import the PDF parser only when needed (client-side only)
    if (typeof window === "undefined") {
      // We're on the server, return a message
      return "PDF parsing is only available in the browser. The file will be processed when viewed in the browser.";
    }

    // We're in the browser, dynamically import the PDF parser
    const pdfToTextModule = await import("react-pdftotext");
    const pdfToText = pdfToTextModule.default;

    const text = await pdfToText(file);
    return text.trim();
  } catch (error) {
    console.error("Error parsing PDF:", error);
    throw new Error(
      "Failed to extract text from PDF. Please try a different file format."
    );
  }
}
```

## UI Component Structure (2025-03-12)

The ApplyRight feature follows a step-by-step wizard pattern with the following components:

1. **FileUpload** - Handles resume file uploads with drag-and-drop and click-to-browse functionality
2. **JobDescription** - Allows users to input job description text with a single "Continue" button
3. **Transform** - Processes the resume against the job description
4. **Results** - Displays and allows download of transformed documents

### UI Improvements

- Made the entire drop area in FileUpload component clickable, not just the button
- Removed redundant "Next" button in job description step to avoid confusion with the "Continue" button
- Ensured consistent button placement and styling throughout the wizard flow

## API Integration

The ApplyRight feature uses the Gemini API for resume transformation. The API route is implemented at `/api/apply-right/transform` and includes:

1. Request validation using Zod
2. Error handling
3. Fallback mode for when the API is unavailable

## User Experience Considerations

1. Clear feedback through toast notifications
2. Step-by-step guided process
3. Responsive design for all screen sizes
4. Comprehensive error handling

## PDF Generation Implementation - [2023-06-15]

The ApplyRight feature now includes professional PDF generation for the transformed resumes and cover letters. This implementation uses the jsPDF library to create well-formatted PDF documents with proper headers, footers, and intelligent text layout.

### Key Features

1. **Professional Document Formatting**:

   - Document headers with titles
   - Page numbers in footers
   - Intelligent paragraph detection and formatting
   - Multi-page support with proper pagination
   - Heading detection and emphasis

2. **User Experience Improvements**:

   - Clear "Download PDF" buttons
   - Descriptive text explaining the PDF download feature
   - Success notifications when PDFs are downloaded
   - Consistent document properties for better organization

3. **Technical Implementation**:
   - Uses jsPDF library for PDF generation
   - Client-side generation for immediate download
   - No server-side processing required
   - Intelligent text parsing to maintain document structure

This enhancement significantly improves the user experience by providing professionally formatted documents that are ready for immediate use in job applications.

# ApplyRight Feature UI and PDF Improvements - [2025-03-12 06:45:00]

## Resume and Cover Letter Preview Enhancement

The ApplyRight feature's UI has been significantly improved with enhanced resume and cover letter previews. Key improvements include:

1. **Intelligent Section Detection**:

   - Automatically identifies and styles different resume sections (summary, experience, education, etc.)
   - Detects and properly formats contact information
   - Recognizes and formats company/position information

2. **Enhanced Bullet Point Rendering**:

   - Proper indentation based on original formatting
   - Visual bullet points with consistent styling
   - Proper spacing and alignment

3. **Typography Improvements**:

   - Better font choices (sans-serif for resume, serif for cover letter)
   - Improved spacing and line height
   - Better text color management for readability

4. **Hydration Error Fix**:
   - Fixed HTML structure issue where a Badge component (div) was incorrectly placed inside a paragraph tag
   - Replaced p tag with properly styled div to maintain visual appearance while fixing the error

## PDF Generation Enhancement

The PDF generation for both resumes and cover letters has been significantly improved:

1. **Professional Layout**:

   - Added proper headers with candidate name and contact information
   - Improved section headers with background colors and proper spacing
   - Better page margins and content flow
   - Professional footer with page numbers

2. **Intelligent Content Processing**:

   - Automatically extracts and positions candidate name, contact info, and dates
   - Detects and properly formats section headers
   - Recognizes and formats bullet points with proper indentation
   - Identifies company/position information and applies appropriate styling

3. **Dynamic Filename Generation**:

   - Creates filenames based on candidate name when available
   - Adds appropriate file type suffix (Resume/Cover_Letter)

4. **Typography and Styling**:
   - Improved font selection and sizing
   - Better text color management for readability
   - Proper spacing between sections and paragraphs
   - Consistent styling throughout the document

These improvements significantly enhance the user experience by providing more professional-looking previews and downloads, making the ApplyRight feature more valuable to users.

### ApplyRight UI and PDF Improvements - [2023-07-15]

- The resume preview component uses intelligent section detection to apply appropriate styling:

  - Candidate name (usually at the top, often with asterisks) gets large, centered styling
  - Contact information (contains |, @, or brackets) gets centered, smaller styling
  - Section headers (contains \*\* or starts with #) get bold styling with a bottom border
  - Bullet points are rendered with CSS styling instead of text bullets to avoid duplication
  - Company/position lines (contains Ltd, Inc, LLC, or dates) get semi-bold styling
  - Summary sections get slightly lighter text color

- The cover letter preview component uses special formatting for different sections:

  - Date lines (contains month names or date formats) are right-aligned
  - Sender and recipient information get proper spacing
  - Greeting lines (starts with "Dear" or "To Whom") get extra spacing
  - Closing lines (Sincerely, Best regards, etc.) get special formatting
  - Signature lines get bold styling with extra spacing
  - All text uses serif fonts for a more formal appearance

- Resume PDF generation includes:

  - Professional header with light gray background
  - Candidate name extraction from the first few lines
  - Contact information display below the name
  - Section headers with background color and divider lines
  - Bullet points with proper indentation based on the original spacing
  - Special handling for company/position lines
  - Different styling for summary sections
  - Page numbers in the footer
  - Dynamic filename based on candidate name

- Cover Letter PDF generation includes:
  - Proper business letter format with wider margins
  - Intelligent extraction of sender, recipient, and date information
  - Special formatting for greeting and closing sections
  - Proper paragraph spacing for readability
  - Page numbers in the footer
  - Dynamic filename based on sender name

## ApplyRight Feature Improvements - March 12, 2025

### LLM Model Selection

- Gemini 2.0 Flash provides significantly better quality output than Gemini 1.5 Flash for resume and cover letter generation
- The model is better at following specific formatting instructions and avoiding placeholder text
- Response times are comparable between the two models

### Prompt Engineering Insights

- Explicit instructions to NEVER use placeholder text are critical for quality output
- Including examples of desired output format (e.g., "leading to a 20% increase" instead of "Quantifiable Achievement (e.g., 20%)") significantly improves results
- For cover letter generation, specific instructions about paragraph alignment and avoiding generic terms like "Platform" are necessary
- The LLM responds well to numbered lists of specific instructions in the prompt

### Fallback Function Design

- Regex replacements are effective for handling common placeholder patterns
- Maintaining separate fallback functions for resume and cover letter generation provides better control over the output quality
- The fallback functions should mirror the LLM's expected output format as closely as possible

### UI/UX Considerations

- Keyword matching visualization should accurately reflect the actual matches in the content
- Green checkmarks provide clear visual feedback for matched keywords
- Hover tooltips with match percentages add valuable context for users
- The overall match score should align with the visual indicators (all green = 100%)

These insights will help maintain high-quality output in the ApplyRight feature and can be applied to other LLM-powered features in the application.

## Accessibility Standards [2025-03-12 20:24:00]

- All UI elements must meet WCAG 2.1 AA standards for color contrast
- Navigation links use text-gray-900 for sufficient contrast against light backgrounds
- Form elements must have proper labels or aria-labels
- Buttons without visible text must have aria-labels
- All interactive elements must have proper focus states
- The application has achieved a perfect accessibility score of 100/100
- Do not attempt to fix accessibility issues that have already been resolved

# CSS Architecture Rules - March 12, 2024, 20:45:00

## CSS File Organization

1. Critical CSS (`/src/app/critical.css`):

   - Only include above-the-fold styles
   - Keep file size under 14KB (compressed)
   - Use CSS variables for theming

2. Global CSS (`/src/app/globals.css`):

   - Include Tailwind directives
   - Define CSS variables
   - Base element styles

3. Non-Critical CSS (`/public/styles/non-critical.css`):
   - Below-the-fold styles
   - Utility classes
   - Component variations
   - Animations and transitions

## CSS Loading Rules

1. Critical CSS:

   - Must be inlined in the head
   - No render-blocking imports
   - Use preload for critical fonts

2. Non-Critical CSS:
   - Must be loaded asynchronously
   - Include fallback for no-JS
   - Use resource hints

## CSS Best Practices

1. Mobile-First Development:

   - Start with mobile styles
   - Use standard breakpoints
   - Test on multiple devices

2. Performance:

   - Minimize specificity
   - Avoid deep nesting
   - Use utility classes
   - Consolidate duplicate styles

3. Accessibility:

   - Maintain WCAG contrast ratios
   - Provide focus indicators
   - Support reduced motion

4. Dark Mode:
   - Use CSS variables
   - Test color contrast
   - Maintain readability

# Cursor Rules - Synthalyst Web Application [2025-03-13]

## Project Structure [2025-03-13]

### Directory Organization [2025-03-13]

- The main application code is in the `nextjs-app` directory
- All development should be done within this directory
- The development server runs on port 3001

### File Naming Conventions [2025-03-13]

- Use kebab-case for file names (e.g., `file-name.tsx`)
- Use PascalCase for component names (e.g., `ComponentName.tsx`)
- Use camelCase for utility functions and hooks (e.g., `useHookName.ts`)

## SEO Implementation [2025-03-13]

### Metadata [2025-03-13]

- Use Next.js Metadata API for all metadata
- Define metadata in layout.tsx for site-wide metadata
- Override metadata in page.tsx files for page-specific metadata
- Include title, description, and OpenGraph data for all pages

### JSON-LD [2025-03-13]

- Implement JSON-LD structured data for all pages
- Use the script tag with type="application/ld+json"
- Include appropriate schema based on page content
- Validate JSON-LD using Google's Structured Data Testing Tool

### Sitemap and Robots [2025-03-13]

- Use dynamic sitemap.ts for sitemap generation
- Use dynamic robots.ts for robots.txt configuration
- Do not create static files in the public directory for these

## Accessibility Guidelines [2025-03-13]

### Color Contrast [2025-03-13]

- Ensure all text has sufficient color contrast (4.5:1 for normal text, 3:1 for large text)
- Use text-gray-900 instead of text-gray-700 for better contrast
- Update muted-foreground color variables in both light and dark modes

### Heading Structure [2025-03-13]

- Use proper heading hierarchy (h1 -> h2 -> h3)
- Avoid skipping heading levels
- Each page should have only one h1 element

### ARIA Attributes [2025-03-13]

- Add aria-label to buttons without visible text
- Add proper labels to form elements
- Use aria-hidden for decorative elements

## Performance Optimization [2025-03-13]

### CSS Strategy [2025-03-13]

- Use critical.css for above-the-fold content
- Load non-critical CSS asynchronously
- Use Tailwind CSS for utility-first styling
- Minimize custom CSS

### JavaScript Optimization [2025-03-13]

- Use next/script with appropriate strategy
- Implement code splitting for large components
- Defer non-critical JavaScript
- Minimize third-party scripts

### Image Optimization [2025-03-13]

- Use next/image for automatic optimization
- Implement responsive images with srcset
- Use WebP format when supported
- Implement lazy loading for below-the-fold images

## Component Patterns [2025-03-13]

### Layout Components [2025-03-13]

- Use RootLayout for site-wide layout
- Define page-specific layouts as needed
- Include proper metadata in layout components

### Page Components [2025-03-13]

- Use page.tsx for page components
- Override metadata in page components
- Implement JSON-LD in page components

### UI Components [2025-03-13]

- Use shadcn/ui components when available
- Create custom components when needed
- Ensure all components are accessible

## API Patterns [2025-03-13]

### API Routes [2025-03-13]

- Use Next.js API routes for backend functionality
- Implement proper error handling
- Use TypeScript for type safety
- Validate input with Zod

### Data Fetching [2025-03-13]

- Use server components for data fetching when possible
- Implement proper error handling
- Use TypeScript for type safety
- Cache data when appropriate

## Testing Guidelines [2025-03-13]

### Component Testing [2025-03-13]

- Test rendering and user interactions
- Test form validation and submission
- Test loading states and error handling
- Test accessibility

### API Testing [2025-03-13]

- Test success and error cases
- Validate response structure
- Test pagination and filtering
- Mock external dependencies

## SEO and Performance Optimization Patterns - [2025-03-13 01:55:00]

- Metadata implementation:

  - Use the `metadata` export in layout.tsx or page.tsx files
  - Include title, description, keywords, and OpenGraph data
  - Add canonical URLs using the alternates property
  - Example:
    ```typescript
    export const metadata: Metadata = {
      title: "Page Title | Synthalyst",
      description: "Page description for better SEO",
      keywords: ["keyword1", "keyword2"],
      openGraph: {
        title: "Page Title | Synthalyst",
        description: "Page description for better SEO",
        url: "https://synthalyst.com/page-path",
        type: "website",
        images: [{ url: "/icons/og-image.png", width: 1200, height: 630 }],
      },
      twitter: {
        card: "summary_large_image",
        title: "Page Title | Synthalyst",
        description: "Page description for better SEO",
        images: ["/icons/twitter-image.png"],
      },
      alternates: {
        canonical: "https://synthalyst.com/page-path",
      },
    };
    ```

- Structured data implementation:

  - Use JSON-LD format in layout.tsx or page.tsx files
  - Add the script tag in the component's return statement
  - Example:

    ```typescript
    const jsonLd = {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      name: "Application Name",
      description: "Application description",
    };

    return (
      <>
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
        />
        {children}
      </>
    );
    ```

- Resource hints for performance:

  - Add preconnect for domains that will be used
  - Add dns-prefetch for domains that might be used
  - Example:
    ```html
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin="anonymous"
    />
    <link rel="dns-prefetch" href="https://res.cloudinary.com" />
    ```

- JavaScript optimization:

  - Use conditional execution for deferred JavaScript
  - Implement Intersection Observer for lazy loading
  - Preload critical images
  - Example:

    ```javascript
    // Defer non-critical JavaScript
    if (document.readyState === "complete") {
      deferJsLoad();
    } else {
      window.addEventListener("load", deferJsLoad);
    }

    // Lazy load images with Intersection Observer
    if ("IntersectionObserver" in window) {
      const lazyLoadObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const target = entry.target;
            if (target.dataset.src) {
              target.src = target.dataset.src;
              target.removeAttribute("data-src");
            }
            lazyLoadObserver.unobserve(target);
          }
        });
      });

      document.querySelectorAll("[data-src]").forEach((el) => {
        lazyLoadObserver.observe(el);
      });
    }
    ```

- Webpack configuration for performance:
  - Implement code splitting with cache groups
  - Add better minification settings for production
  - Example:
    ```javascript
    // In next.config.js
    config.optimization = {
      splitChunks: {
        chunks: "all",
        cacheGroups: {
          vendor: {
            name: "vendor",
            test: /node_modules/,
            priority: 20,
          },
          common: {
            name: "common",
            minChunks: 2,
            priority: 10,
          },
        },
      },
    };
    ```

## Fixed Issues [2025-03-13 06:20:00]

### Logo 404 Error

- The application was showing a 404 error for logo.png in the console
- Fixed by copying the logo.png file to the public directory
- This ensures the logo loads correctly without any console errors

### Interview Prep Plan Formatting

- TIMELINE and PHASE sections were not properly formatted in the interview prep plan
- Fixed by implementing proper regex patterns and styling in the SimpleMarkdown component
- Enhanced the PDF export component to properly handle these special sections
- This improves readability and professional appearance of the interview prep plan

### React Server-Side Rendering Best Practices - [2025-03-13 06:50:00]

- Use `useIsomorphicLayoutEffect` instead of `useLayoutEffect` for components that might be rendered on the server
- The utility is located at `src/lib/useIsomorphicLayoutEffect.ts`
- This prevents the "useLayoutEffect does nothing on the server" warning
- Implementation:

  ```typescript
  import { useLayoutEffect, useEffect } from "react";

  // Use useLayoutEffect on the client, but fall back to useEffect during SSR
  const useIsomorphicLayoutEffect =
    typeof window !== "undefined" ? useLayoutEffect : useEffect;

  export default useIsomorphicLayoutEffect;
  ```

- Import and use it like this:

  ```typescript
  import useIsomorphicLayoutEffect from "@/lib/useIsomorphicLayoutEffect";

  function MyComponent() {
    useIsomorphicLayoutEffect(() => {
      // Your layout effect code here
    }, []);

    return <div>My Component</div>;
  }
  ```

### SimpleMarkdown Component Patterns - [2025-03-13 06:50:00]

- The SimpleMarkdown component in `src/app/interview-prep/page.tsx` handles custom markdown formatting
- Special section handling requires regex patterns for both:
  - Sections at the beginning of lines (e.g., `^TIMELINE:`)
  - Sections in the middle of text (e.g., `(\S+\s*)TIMELINE:`)
- Example pattern for handling both cases:
  ```typescript
  // Handle when it appears in the middle of text
  formattedText = formattedText.replace(
    /(\S+\s*)TIMELINE:/g,
    '$1<br /><span class="text-md font-bold text-primary/90 mt-4 mb-2 inline-block">TIMELINE:</span>'
  );
  // Also handle when it appears at the beginning of a line
  formattedText = formattedText.replace(
    /^TIMELINE:/gm,
    '<span class="text-md font-bold text-primary/90 mt-4 mb-2 inline-block">TIMELINE:</span>'
  );
  ```
- The component uses a series of regex replacements to transform markdown-like syntax into styled HTML
- Order of replacements matters to avoid conflicts between patterns

### SHA224 Crypto Module Fix - [2025-03-13 18:20:00]

- If encountering "Cannot set properties of undefined (setting 'SHA224')" error:
  1. Ensure crypto-browserify is properly configured as a fallback for the crypto module
  2. Use the crypto-polyfill.js utility to initialize the crypto library before PDF operations
  3. Initialize the crypto polyfill in components that use PDF generation
  4. Use the pdf-utils.js utility functions for safer PDF generation and download
  5. Modify webpack configuration to prevent mangling of crypto-related properties
- The error occurs in production builds due to minification issues with the crypto library
- The solution involves:
  - Proper initialization of the crypto library
  - Prevention of property mangling during minification
  - Safe utility functions for PDF operations
- Affected components:
  - TrainingPlanClient
  - TrainingPlanPDF
  - PDFRenderer
  - Any component that uses PDF generation

### TypeScript Type Checking Strategy - [2025-03-13 19:30:00]

- The project uses a phased approach to TypeScript type checking:

  1. Phase 1: Use relaxed type checking with test files excluded
  2. Phase 2: Fix critical production code type errors
  3. Phase 3: Fix test file type errors
  4. Phase 4: Enable strict type checking

- Type checking can be run with `npm run typecheck`
- A custom TypeScript configuration is used: `tsconfig.typecheck.json`
- The Next.js configuration is set to use this custom TypeScript config
- Common type errors to fix:

  - Next.js 15 route parameters should use `Promise<{ id: string }>` type
  - Prisma schema mismatches (properties that don't exist in the schema)
  - Component prop type errors (props that don't match component definitions)
  - Missing type declarations for external libraries

- Documentation for the type checking plan is in `TYPE_CHECKING_PLAN.md`

## TypeScript Type Checking [2025-03-14 12:00:00]

The project uses TypeScript for type safety. We've implemented a comprehensive type checking strategy:

1. **Component Props**: All component props must be properly typed with interfaces or types.

   - Example: `interface BreadcrumbProps { items: BreadcrumbItem[]; className?: string; }`
   - Components should destructure props in their function signatures
   - Optional props should use the `?` syntax

2. **API Routes**: API routes should validate input with Zod and have proper type annotations.

   - Use Zod schemas for request validation
   - Explicitly type request handlers with appropriate return types
   - Handle type mismatches with proper error messages

3. **Type Assertions**: Use `@ts-expect-error` comments sparingly and only when necessary.

   - Always include a clear explanation of why the error is being suppressed
   - Example: `// @ts-expect-error - TypeScript doesn't preserve required properties when spreading`
   - Prefer fixing the underlying type issue over suppressing errors

4. **Library Compatibility**: Handle third-party library type issues with appropriate workarounds.

   - Use type assertions when necessary for library compatibility
   - Create adapter functions or wrapper components for problematic libraries
   - Document any workarounds in comments

5. **Type Checking Process**:
   - Run `npm run typecheck` before committing changes
   - Address all type errors before merging code
   - Update TYPE_CHECKING_PLAN.md with progress and next steps

This approach has successfully eliminated all TypeScript errors in the codebase, improving code quality and reducing potential runtime errors.

### CSS Conflict Resolution Patterns - [2025-03-14 15:35:00]

- When encountering styling differences between development and production environments:
  1. Inspect the production environment to identify conflicting CSS classes
  2. Create custom classes with the `synthalyst-` prefix to avoid conflicts
  3. Use higher specificity selectors or `!important` flags when necessary
  4. Implement responsive behavior using media queries
  5. Test changes in both development and production environments
- Common sources of CSS conflicts:
  - Non-critical CSS loaded asynchronously in production
  - Third-party CSS overriding application styles
  - CSS ordering differences in production builds
  - Minification and optimization changing CSS specificity
- Example solution pattern:

  ```css
  /* Custom class with prefix */
  .synthalyst-custom-element {
    display: flex !important;
    flex-direction: column;
  }

  /* Responsive behavior */
  @media (min-width: 640px) {
    .synthalyst-custom-element {
      flex-direction: row !important;
    }
  }
  ```

- Always maintain responsive behavior when fixing CSS conflicts
- Document CSS fixes in comments for future reference

## Accessibility and Performance Insights - [2025-03-14 21:30:00]

### Accessibility Audit Results - [2025-03-14 21:30:00]

- Critical accessibility issues identified:
  - Buttons without accessible names in the Training Plan page
  - Color contrast issues with links (3.67 ratio, below the required 4.5:1)
- Overall accessibility score: 90/100
- Prioritized recommendations:
  - Add proper labels to all interactive elements
  - Improve color contrast for better readability
  - Fix low contrast text for better readability
- All buttons must have accessible names through one of these methods:
  - Inner text visible to screen readers
  - aria-label attribute
  - aria-labelledby attribute
  - title attribute
  - Explicit or implicit label
- Color contrast must meet WCAG standards:
  - Text must have a contrast ratio of at least 4.5:1 against its background
  - Large text (18pt or 14pt bold) must have a contrast ratio of at least 3:1

### Performance Audit Results - [2025-03-14 21:30:00]

- Performance issues identified:
  - Slow Largest Contentful Paint (LCP): 3031ms (failing Core Web Vital)
  - Slow First Contentful Paint (FCP): 1668ms
  - High JavaScript execution time
  - Total Time to Interactive (TTI): 37718ms
- Overall performance score: 52/100
- Prioritized recommendations:
  - Improve Largest Contentful Paint (LCP)
  - Reduce JavaScript execution time
- Core Web Vitals targets:
  - LCP should be under 2.5 seconds
  - FID (First Input Delay) should be under 100ms
  - CLS (Cumulative Layout Shift) should be under 0.1
- Performance optimization strategies:
  - Optimize CSS loading strategy
  - Implement JavaScript optimization techniques
  - Configure image optimization
  - Reduce render-blocking resources
  - Implement code splitting and lazy loading
  - Optimize server-side rendering
  - Minimize main thread work

## Accessibility Best Practices - [2025-03-14 21:30:00]

### Button Accessibility - [2025-03-14 21:30:00]

- All buttons must have accessible names through one of these methods:
  - Inner text visible to screen readers
  - aria-label attribute
  - aria-labelledby attribute
  - title attribute
  - Explicit or implicit label
- Icon-only buttons must always have an aria-label attribute
- Examples of proper button accessibility:

  ```tsx
  // Button with icon only
  <Button
    type="button"
    variant="ghost"
    size="icon"
    onClick={handleClick}
    aria-label="Remove item"
  >
    <X className="h-4 w-4" />
  </Button>

  // Select trigger with accessible name
  <SelectTrigger className="w-32" aria-label="Select duration unit">
    <SelectValue placeholder="Unit" />
  </SelectTrigger>
  ```

### Color Contrast - [2025-03-14 21:30:00]

- All text must have a contrast ratio of at least 4.5:1 against its background
- Large text (18pt or 14pt bold) must have a contrast ratio of at least 3:1
- Use the "default" button variant instead of "outline" for better contrast
- Examples of proper color contrast:
  ```tsx
  // Good contrast with default variant
  <Button asChild variant="default">
    <Link href="/blog/training-plan-creator-guide">
      <HelpCircle className="mr-2 h-4 w-4" />
      Read the comprehensive guide
    </Link>
  </Button>
  ```

## Feedback System Implementation [2025-03-14 23:45:00]

### Dual Storage Strategy

- The feedback system uses a dual storage strategy:
  - Primary: Prisma database with AppFeedback model
  - Fallback: File-based JSON storage in feedback-data.json
- The system attempts to use Prisma first, and if it fails (e.g., due to missing model or permissions), it falls back to file storage
- The fallback mechanism is transparent to users, who receive a success message in both cases

### File Path Resolution

- The feedback-data.json file must be stored in the nextjs-app directory
- Path resolution uses process.cwd() which can vary depending on where the server is started
- Always use path.resolve() with conditional logic to ensure the file is stored in the correct location:

```typescript
const feedbackFilePath = path.resolve(
  process.cwd().includes("nextjs-app")
    ? process.cwd()
    : path.join(process.cwd(), "nextjs-app"),
  "feedback-data.json"
);
```

### Prisma Type Extensions

- The AppFeedback model may not be recognized by TypeScript in the Prisma client
- Use type assertions to extend the Prisma client type:

```typescript
type PrismaWithAppFeedback = typeof prisma & {
  appFeedback: {
    // Define methods and their types here
    findMany: (args?: {
      where?: { appName?: string };
      orderBy?: { createdAt: "asc" | "desc" };
    }) => Promise<
      Array<{
        // Define return type here
        id: string;
        appName: string;
        // Other fields...
      }>
    >;
    // Other methods...
  };
};
```

### Debugging Techniques

- Add comprehensive logging throughout the feedback system
- Log file paths, existence checks, and data read/write operations
- Create diagnostic scripts (check-feedback.mjs, check-cwd.js) for troubleshooting
- Use try-catch blocks with detailed error logging including stack traces

### Server Startup Location

- Always start the development server from the nextjs-app directory
- Use `cd nextjs-app && npm run dev` to ensure correct working directory
- Check the current directory with `pwd` before starting the server
- Verify the presence of package.json with `ls -la package.json`

## Module System Configuration [2025-03-14 23:50:00]

- The application uses CommonJS module format (require/module.exports) instead of ES modules
- Configuration files (tailwind.config.ts, postcss.config.ts) must use module.exports syntax
- Utility scripts use .cjs extension to ensure they are treated as CommonJS modules
- When creating new configuration files, always use module.exports syntax
- When creating new utility scripts, use .cjs extension if they need to be executed directly
- The package.json does NOT have "type": "module" to ensure CommonJS compatibility

## Prisma Model Casing Pattern - March 14, 2025

When working with Prisma models in code:

1. Always use camelCase for model names when accessing them through the Prisma client:

   - `prisma.questionLibrary` (correct)
   - `prisma.QuestionLibrary` (incorrect)
   - `prisma.userSavedQuestion` (correct)
   - `prisma.UserSavedQuestion` (incorrect)

2. Ensure interface definitions match the actual database schema:

   - Make fields nullable in TypeScript interfaces if they can be null in the database
   - Example: `answer: string | null` instead of just `answer: string`

3. This pattern applies to all Prisma client operations:
   - findMany
   - findUnique
   - findFirst
   - create
   - update
   - delete
   - count
   - etc.

## Audio Component Integration Pattern - March 14, 2025

When working with audio components in the application:

1. Import audio components from the components library:

   ```typescript
   import {
     AudioRecorder,
     TextToSpeechPlayer,
   } from "@/components/interview-prep";
   ```

2. Add state for audio data:

   ```typescript
   const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
   const [audioUrl, setAudioUrl] = useState<string | null>(null);
   const [isAudioMode, setIsAudioMode] = useState(false);
   ```

3. Handle audio recording completion:

   ```typescript
   const handleRecordingComplete = (blob: Blob, url: string) => {
     setAudioBlob(blob);
     setAudioUrl(url);
   };
   ```

4. Include audio URL in API requests:

   ```typescript
   interface RequestBody {
     // Other fields
     audioUrl?: string;
   }

   const requestBody: RequestBody = {
     // Other fields
     responseText: isAudioMode ? "Audio response submitted" : responseText,
   };

   if (isAudioMode && audioUrl) {
     requestBody.audioUrl = audioUrl;
   }
   ```

5. Add UI toggle for switching between text and audio modes:

   ```tsx
   <div className="flex items-center justify-end space-x-2 mb-2">
     <Label
       htmlFor="input-mode"
       className={isAudioMode ? "text-primary" : "text-muted-foreground"}
     >
       {isAudioMode ? "Voice Response" : "Text Response"}
     </Label>
     <Switch
       id="input-mode"
       checked={isAudioMode}
       onCheckedChange={toggleInputMode}
     />
   </div>
   ```

6. Conditionally render audio or text input based on mode:

   ```tsx
   {
     isAudioMode ? (
       <AudioRecorder
         onRecordingComplete={handleRecordingComplete}
         maxDuration={2 * 60 * 1000}
         showPlayer={true}
         showProgress={true}
       />
     ) : (
       <textarea
         value={responseText}
         onChange={(e) => setResponseText(e.target.value)}
       />
     );
   }
   ```

7. For text-to-speech, use the TextToSpeechPlayer component:

   ```tsx
   <TextToSpeechPlayer text={textToRead} showSettings={false} />
   ```

8. When displaying responses, handle both text and audio:
   ```tsx
   {
     audioUrl ? (
       <div>
         <audio src={audioUrl} controls />
         <p>Audio response submitted</p>
       </div>
     ) : (
       <p>{responseText}</p>
     );
   }
   ```

### AudioRecorder Component Pattern - March 14, 2025

- The AudioRecorder component provides high-quality audio recording for the Mock Interview feature
- Key implementation details:

  ```tsx
  // Import the component
  import { AudioRecorder } from "@/components/interview-prep/AudioRecorder";

  // Use the component with callback for handling the completed recording
  <AudioRecorder
    onRecordingComplete={(blob, url) => {
      // Handle the recording blob and URL
      setAudioBlob(blob);
      setAudioUrl(url);
    }}
    maxDuration={120000} // 2 minutes in milliseconds
    showPlayer={true}
    showProgress={true}
    autoRequestPermission={true}
  />;
  ```

- Configuration options:

  - `onRecordingComplete`: Callback function that receives the audio blob and URL
  - `maxDuration`: Maximum recording duration in milliseconds (default: 2 minutes)
  - `showPlayer`: Whether to show the audio player (default: true)
  - `showProgress`: Whether to show the progress bar (default: true)
  - `autoRequestPermission`: Whether to auto-request microphone permission (default: true)

- Audio quality settings:

  - Uses "audio/webm;codecs=opus" format for optimal voice quality
  - Disables noise reduction, echo cancellation, and auto gain control
  - Uses 48000Hz sample rate for better voice clarity
  - Configures mono recording (single channel) for voice

- UI feedback features:

  - Real-time status messages that update as recording progresses
  - Color coding (red for recording, green for success)
  - Button animations for better click feedback
  - Warning messages when approaching maximum duration
  - Progress bar showing recording duration

- Error handling:

  - Descriptive error messages for common issues
  - Clear instructions for resolving permission problems
  - Visual indicators for error states

- Best practices:
  - Always provide an onRecordingComplete handler
  - Consider mobile users with appropriate button sizes
  - Test on different browsers (Chrome, Firefox, Safari)
  - Provide alternative text input for accessibility

# Cursor Rules for Synthalyst Project

## LLM Model Strategy - 2025-03-15

### Model Selection Criteria

- Cost efficiency is the primary consideration for model selection
- Quality of output is secondary but still important
- Latency should be minimized for interactive features
- Multilingual support is required for educational content

### Recommended Models by Feature

- **Knowledge GPT**: GPT-4o-Mini ($0.15/input, $0.6/output)
- **Learning Content Creator**: Gemini 1.5 Flash ($0.075/input, $0.3/output)

### Tiered Approach Implementation

1. **Tier 1 (Simple Queries)**: Llama 3.2 3B for basic questions and content
2. **Tier 2 (Medium Complexity)**: GPT-4o-Mini or Gemini 1.5 Flash for more complex needs
3. **Tier 3 (High Complexity)**: GPT-4o reserved for only the most complex educational queries

### Implementation Guidelines

- Implement a smart router to direct queries to the appropriate model based on complexity
- Develop a caching system for common educational queries to reduce API costs
- Create a fallback mechanism that starts with lower-cost models and escalates only when necessary
- Implement cost controls including token counting, budgeting, and usage monitoring
- Add user feedback mechanisms to continuously improve the quality of responses

## Knowledge GPT Implementation - 2025-03-15

### Prompt Strategy

- Use chain-of-thought prompting to guide the model through a structured reasoning process
- Include explicit instructions for output format (plain text, not markdown)
- Provide context about the educational level and background of the user
- Include examples of high-quality responses for different types of questions

### API Implementation

- Use streaming responses to improve user experience for longer answers
- Implement proper error handling with fallback content generation
- Add topic extraction for better organization and retrieval of past questions
- Store questions and answers in the database for future reference and analysis

## Learning Content Creator Implementation - 2025-03-15

### Content Generation Process

1. **Input Collection**: Gather user specifications including subject, educational level, content type, and learning objectives
2. **Content Planning**: Generate a structured outline based on user inputs
3. **Content Generation**: Create detailed content following the outline
4. **Review and Refinement**: Ensure content meets educational standards and user requirements

### API Implementation

- Use a two-step process: first generate an outline, then expand it into full content
- Implement proper error handling with fallback content generation
- Add content validation to ensure educational quality and accuracy
- Store generated content in the database for future reference and editing

## UI Implementation Guidelines - 2025-03-15

### Knowledge GPT UI

- Use a chat-like interface for question input and answer display
- Implement a tabbed interface for asking questions and viewing history
- Add topic filtering for better organization of past questions
- Include a loading state with progress indication for longer responses

### Learning Content Creator UI

- Use a form-based interface for content specifications
- Implement a tabbed interface for content creation and viewing saved content
- Add content preview with proper formatting
- Include download options for different formats (PDF, DOCX, etc.)

## Database Schema - 2025-03-15

### Knowledge GPT Tables

- `KnowledgeEntry`: Stores questions, answers, topics, and user information
- `KnowledgeTopic`: Stores extracted topics for better organization and retrieval

### Learning Content Creator Tables

- `LearningContentEntry`: Stores content specifications, generated content, and user information
- `LearningContentTemplate`: Stores reusable templates for different content types

# Cursor Rules - March 15, 2025

## Model Optimization Strategy - March 15, 2025

- Knowledge GPT and Learning Creator use optimized AI models for cost efficiency and quality
- A tiered approach is implemented to select models based on task complexity, content length, language support, and cost priority
- The model router service in `/lib/ai/model-router.ts` handles model selection and API calls
- Both features support multilingual responses based on user language selection
- **IMPORTANT**: Model information must NEVER be displayed to users in the UI
- We present a unified AI-powered experience without revealing specific model details

## API Integration - March 15, 2025

- Knowledge GPT API in `/api/knowledge-gpt/route.ts` uses the model router to select the appropriate model
- Learning Content API in `/api/learning-content/route.ts` uses the model router to select the appropriate model
- Both APIs support language selection and store the model used in the database for internal analytics only
- System prompts are enhanced with multilingual support using the `createMultilingualSystemPrompt` function
- Model information must be removed from any user-facing responses

## UI Components - March 15, 2025

- Language selector component in `/components/ui/language-selector.tsx` allows users to select their preferred language
- The component shows supported languages and detects browser language as default
- **CRITICAL**: Remove any UI elements that display model information to users
- Present a unified "AI-powered" experience without revealing which specific models are used
- Error handling is improved with proper error alerts and messages

## Database Schema - March 15, 2025

- KnowledgeEntry and LearningContentEntry models include language and modelUsed fields
- Language field defaults to "English" and is used for filtering and display
- ModelUsed field stores the model used for each entry for internal analytics only
- Model information must never be exposed in user-facing queries

## Environment Variables - March 15, 2025

- OPENAI_API_KEY is required for OpenAI API calls
- GOOGLE_AI_API_KEY is required for Google AI API calls
- Both keys should be added to the .env file for local development

### API Key Naming Conventions - [2025-03-15 21:45:23]

- Always use `GEMINI_API_KEY` environment variable for Google AI/Gemini models
- Never use alternative names like `GOOGLE_AI_API_KEY` for Gemini API access
- When initializing the Google Generative AI client, always use:
  ```typescript
  const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || "");
  ```
- This applies to both server-side and client-side code that needs to access Gemini models
- For OpenAI models, use `OPENAI_API_KEY` environment variable
- For client-side access to OpenAI, use `NEXT_PUBLIC_OPENAI_API_KEY`
- Always use the API route pattern for client-side model access to maintain security

## Knowledge GPT Web Search Integration (March 16, 2025)

The Knowledge GPT feature has been enhanced with web search capability to provide up-to-date information. This ensures that users receive accurate information even when the model's training data is outdated.

### Implementation Details

1. **Google Custom Search API Integration**:

   - Created a new API route at `/api/web-search` that uses Google Custom Search API
   - Added environment variables for Google Search API key and Search Engine ID
   - Implemented error handling for API failures

2. **System Prompt Updates**:

   - Updated system prompts to include current information
   - Added instructions to use web search results when available
   - Ensured accurate information for current events and facts

3. **UI Updates**:
   - Added information about web search capability to the Knowledge GPT page
   - Updated tips section to mention web search
   - Maintained clean and simple UI while adding new functionality

### Configuration Requirements

To use the web search capability, the following environment variables must be set:

- `GOOGLE_SEARCH_API_KEY`: API key for Google Custom Search API
- `GOOGLE_SEARCH_ENGINE_ID`: Search Engine ID (cx) for Google Programmable Search Engine

### Usage Notes

- Web search is automatically triggered for all Knowledge GPT queries
- Search results are included in the system prompt if available
- The model combines web search results with its own knowledge to provide accurate answers
- If web search fails or returns no results, the model falls back to its own knowledge

## Knowledge GPT Improvements (March 16, 2025)

The Knowledge GPT feature has been enhanced with several improvements:

1. **Smart Web Search Detection**: Added logic to only use web search when necessary, avoiding unnecessary API calls for:

   - Simple math questions (e.g., "what is 20 + 15?")
   - Basic definition questions (e.g., "what is a prime number?")
   - Questions about the assistant itself (e.g., "who are you?")

2. **Improved Text Formatting**:

   - Updated system prompt to instruct the LLM to use proper formatting without asterisks
   - Added client-side formatting to properly render bold text and lists
   - Implemented HTML rendering for assistant messages using dangerouslySetInnerHTML

3. **Enhanced Loading Animation**:
   - Replaced the spinning icon with the three dots animation for better UX
   - Used the LoadingDots component for consistent loading indicators

These improvements enhance the user experience by providing better formatted responses and more efficient API usage.

## Web Search Toggle Feature (March 16, 2025)

The Knowledge GPT feature has been enhanced with a web search toggle button:

1. **User Control**:

   - Added a toggle button in the Knowledge GPT UI to enable/disable web search
   - Button uses Globe/Globe2 icons to visually indicate the current state
   - Default state is OFF to minimize API costs

2. **API Integration**:

   - Modified the generate API route to respect the useWebSearch parameter
   - Updated system prompt to indicate when web search is being used
   - Only performs web search when explicitly enabled by the user

3. **Cost Optimization**:

   - Reduces API costs by only using web search when requested
   - Creates potential for a premium feature (web search could be limited to paid users)
   - Still maintains smart filtering to avoid unnecessary searches even when enabled

4. **UI Updates**:
   - Updated page description to reflect the new toggle feature
   - Modified tips section to mention the toggle feature
   - Clear visual indication of whether web search is ON or OFF

This feature gives users control over their experience while optimizing API costs and creating potential for monetization.
