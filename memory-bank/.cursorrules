# Project Intelligence - 2024-02-27

## UI Patterns - 2024-03-01 15:30

### Loading State Pattern - 2024-03-01 15:30

- Implement minimum loading times (e.g., 500ms) to prevent brief flashes of loading states
- Use consistent loading UI components across the application
- Include both a visual indicator (spinner) and text feedback
- Consider adding secondary messages for longer loading operations
- Measure actual operation time and add delay if needed:
  ```typescript
  const startTime = Date.now();
  // Perform async operation
  const elapsedTime = Date.now() - startTime;
  if (elapsedTime < 500) {
    await new Promise((resolve) => setTimeout(resolve, 500 - elapsedTime));
  }
  ```
- Use larger spinners (h-10 w-10) for primary content areas
- Use smaller spinners (h-4 w-4) for inline or button loading states
- Include appropriate text feedback based on the context

## Testing Patterns - 2024-02-27 14:30

### ARIA Roles in Test Mocks - 2024-03-02 10:15

- When mocking UI components that use ARIA roles, ensure proper parent-child relationships
- Certain ARIA roles require specific parent roles to be valid:
  - `role="option"` elements must be contained within elements with `role="listbox"` or `role="group"`
  - `role="menuitem"` elements must be contained within elements with `role="menu"`
  - `role="tab"` elements must be contained within elements with `role="tablist"`
- If maintaining these relationships is difficult in test mocks, consider:
  1. Removing the role attributes entirely if they're not essential for the test
  2. Ensuring the parent-child relationship is properly established in the mock
  3. Using data attributes instead of ARIA roles for test selection
- Example of fixing ARIA role issues in mocks:

  ```typescript
  // Before (causes linter error)
  SelectItem: ({ children, value }) => (
    <li role="option" aria-selected="false" data-value={value}>
      {children}
    </li>
  ),

  // After (fixed)
  SelectItem: ({ children, value }) => (
    <li data-value={value}>
      {children}
    </li>
  ),
  ```

### Testing Radix UI Components - 2024-02-27 14:30

- Radix UI components use ARIA roles for accessibility
- Select/Combobox components have role="combobox"
- JSDOM has limitations with certain DOM APIs (e.g., hasPointerCapture)
- Instead of trying to interact with Radix UI components directly, prefer:
  1. Using form.setValue() to set values programmatically
  2. Mocking form submission
  3. Testing form validation and submission logic
  4. Testing accessibility roles and labels

### Form Testing Strategy - 2024-02-27 14:30

- Use React Hook Form with Zod validation
- Test form validation errors by submitting empty form
- Test successful form submission with all required fields
- Test API error handling
- Test form reset/clear functionality
- Focus on testing business logic rather than UI interactions

### Common Testing Issues - 2024-02-27 14:30

1. Radix UI Select components:
   - Don't try to click options directly
   - Use keyboard events or setValue() instead
   - Test for proper ARIA roles and labels
2. Form validation:
   - Test all validation rules
   - Test error messages
   - Test required vs optional fields
3. API integration:
   - Mock fetch responses
   - Test success and error cases
   - Verify loading states

### Testing Best Practices - 2024-02-27 14:30

1. Component Testing:
   - Test rendering of all form fields
   - Test form validation
   - Test form submission
   - Test error handling
   - Test loading states
2. Accessibility Testing:
   - Test ARIA roles
   - Test keyboard navigation
   - Test error messages
3. Integration Testing:
   - Test API integration
   - Test form reset
   - Test state management

## Next.js Testing Patterns - 2024-02-28 10:00

### Mocking NextResponse - 2024-02-28 10:00

- NextResponse.json is a static method that returns a Response object
- When mocking NextResponse.json, ensure it returns a proper Response object
- Implement a MockNextResponse class that extends the native Response class
- The json method should:
  1. Accept data and init parameters
  2. JSON stringify the data
  3. Set the Content-Type header to application/json
  4. Return a new MockNextResponse instance
- Example implementation:

```javascript
class MockNextResponse extends Response {
  constructor(body, init) {
    super(body, init);
  }
}

jest.mock("next/server", () => ({
  NextResponse: {
    json: (data, init) => {
      const body = JSON.stringify(data);
      const responseInit = {
        ...init,
        headers: {
          ...init?.headers,
          "Content-Type": "application/json",
        },
      };
      return new MockNextResponse(body, responseInit);
    },
  },
}));
```

### Mocking NextRequest - 2024-02-28 10:00

- NextRequest extends the native Request class
- Implement a MockNextRequest class that simulates NextRequest behavior
- Include methods for json() and clone()
- Example implementation:

```javascript
class MockNextRequest extends Request {
  constructor(input, init) {
    super(input, init);
    this._body = init?.body;
  }

  async json() {
    if (typeof this._body === "string") {
      return JSON.parse(this._body);
    }
    return this._body;
  }

  clone() {
    return new MockNextRequest(this.url, {
      method: this.method,
      headers: this.headers,
      body: this._body,
      mode: this.mode,
      credentials: this.credentials,
      cache: this.cache,
      redirect: this.redirect,
      referrer: this.referrer,
      integrity: this.integrity,
    });
  }
}

jest.mock("next/server", () => ({
  // ... NextResponse mock
  NextRequest: MockNextRequest,
}));
```

### API Route Testing - 2024-02-28 10:00

- When testing API routes, ensure proper mocking of:
  1. NextRequest and NextResponse
  2. External API calls (axios, fetch, etc.)
  3. Database operations (Prisma)
- Use jest.mock() to mock external dependencies
- Test both success and error cases
- Verify response status codes and body content
- Example test structure:

```javascript
describe("API Route", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("returns success response", async () => {
    // Mock external API calls
    axios.post.mockResolvedValueOnce({ data: { result: "success" } });

    // Create mock request
    const req = new MockNextRequest("https://example.com/api", {
      method: "POST",
      body: JSON.stringify({ key: "value" }),
    });

    // Call API route handler
    const response = await handler(req);

    // Verify response
    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data).toEqual({ success: true });
  });

  it("handles validation errors", async () => {
    // Create invalid request
    const req = new MockNextRequest("https://example.com/api", {
      method: "POST",
      body: JSON.stringify({ invalid: "data" }),
    });

    // Call API route handler
    const response = await handler(req);

    // Verify error response
    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data).toEqual({ error: "Validation error" });
  });
});
```

## Form Patterns - 2024-02-27 14:30

### Form Implementation - 2024-02-27 14:30

1. Use React Hook Form for form state management
2. Use Zod for schema validation
3. Use Radix UI components for accessibility
4. Use toast notifications for feedback

### Form Validation - 2024-02-27 14:30

1. Required fields:
   - Minimum length validation
   - Custom error messages
2. Optional fields:
   - Clear validation rules
   - Default values
3. Select fields:
   - Predefined options
   - Default selection

### Form Submission - 2024-02-27 14:30

1. Loading state management
2. Error handling
3. Success feedback
4. Form reset
5. Data transformation

## Project Rules - 2024-02-27 14:30

### Testing Requirements - 2024-02-27 14:30

1. All form components must have:
   - Validation tests
   - Submission tests
   - Error handling tests
   - Reset/clear tests
2. All interactive components must have:
   - Accessibility tests
   - Keyboard navigation tests
3. All API integrations must have:
   - Success case tests
   - Error case tests
   - Loading state tests

### Code Organization - 2024-02-27 14:30

1. Test files should be in **tests** directory
2. Test files should follow component structure
3. Mock files should be in **mocks** directory
4. Test utilities should be in test-utils directory

### Naming Conventions - 2024-02-27 14:30

1. Test files: ComponentName.test.tsx
2. Test descriptions should be clear and descriptive
3. Test utilities should have clear purpose-driven names

## Known Issues - 2024-02-27 14:30

### JSDOM Limitations - 2024-02-27 14:30

1. hasPointerCapture not supported
2. scrollIntoView not supported
3. Some DOM APIs not fully implemented

### Workarounds - 2024-02-27 14:30

1. For Radix UI components:
   - Use keyboard events instead of mouse events
   - Use form.setValue() for select components
   - Test accessibility attributes instead of interactions
2. For DOM APIs:
   - Mock unsupported functions
   - Test side effects instead of implementation
   - Use higher-level abstractions

# Project Rules and Patterns - 2024-02-27

## Testing Patterns [2024-02-27]

### Component Test Structure

```typescript
// Always follow this structure for component tests
describe("ComponentName", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset any global mocks
  });

  it("renders required elements", () => {
    // Test basic rendering
  });

  it("handles user interactions", async () => {
    // Test user interactions
  });

  it("handles API interactions", async () => {
    // Test API calls
  });

  it("handles error cases", async () => {
    // Test error scenarios
  });
});
```

### Mock Component Patterns

```typescript
// Pattern for mocking form components
jest.mock("@/components/ui/form", () => ({
  Form: ({ children }) => <div>{children}</div>,
  FormField: ({ render, name }) =>
    render({
      field: { value: "", onChange: jest.fn(), name },
    }),
  // ... other form components
}));

// Pattern for mocking select components
jest.mock("@/components/ui/select", () => ({
  Select: ({ children, name, ...props }) => (
    <select role="combobox" aria-label={name} title={name} {...props}>
      {children}
    </select>
  ),
  // ... other select components
}));
```

### Accessibility Testing Rules

1. Always include aria-label for form controls
2. Use role attributes appropriately
3. Test with keyboard navigation
4. Follow WCAG guidelines

## Form Component Rules [2024-02-27]

### Form Field Structure

```typescript
<FormField
  control={form.control}
  name="fieldName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Label</FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormDescription>Helper text</FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Error Handling Pattern

```typescript
try {
  // API call
  const response = await fetch("/api/endpoint");
  if (!response.ok) {
    throw new Error("API Error");
  }
  // Success handling
  toast({
    title: "Success",
    description: "Operation completed successfully",
  });
} catch (error) {
  // Error handling
  toast({
    title: "Error",
    description: "Operation failed. Please try again.",
    variant: "destructive",
  });
}
```

## LLM Integration Rules [2024-02-27]

### Salary Data Handling

1. Always validate salary ranges
2. Handle null responses gracefully
3. Provide default values when needed
4. Include currency validation

### Response Processing

1. Validate response format
2. Handle partial responses
3. Implement retry logic
4. Log validation errors

## Project Conventions [2024-02-27]

### File Naming

- Components: PascalCase.tsx
- Tests: ComponentName.test.tsx
- Utilities: camelCase.ts
- Constants: UPPER_CASE.ts

### Import Order

1. React and Next.js imports
2. External libraries
3. Internal components
4. Types and interfaces
5. Utilities and helpers

### Component Structure

1. Props interface
2. Component declaration
3. Hooks and state
4. Helper functions
5. Return statement
6. Styles (if any)

### Git Commit Messages

- feat: New features
- fix: Bug fixes
- test: Test changes
- docs: Documentation
- refactor: Code improvements
- style: Formatting changes

## Learned Patterns [2024-02-27]

### Test Setup

1. Mock external dependencies first
2. Set up user event instance
3. Clear mocks in beforeEach
4. Use proper async/await

### Form Validation

1. Client-side validation first
2. Server-side validation as backup
3. Consistent error messages
4. Clear user feedback

### Error Handling

1. Toast notifications for user feedback
2. Error boundaries for component errors
3. Consistent error format
4. Graceful degradation

### Performance

1. Implement loading states
2. Use skeleton loaders
3. Optimize API calls
4. Handle race conditions

# Command Execution Patterns - 2024-02-27

## NPM Commands

- ALWAYS add a space before npm commands to ensure proper history tracking
- Example: ` npm test` instead of `npm test`
- This applies to all npm commands: ` npm run`, ` npm install`, etc.

## Test Execution Patterns - 2024-02-27

### Common Test Failures

1. Loading State Management

   - Issue: Tests failing due to improper loading state handling
   - Root Cause: Not properly waiting for state updates with act()
   - Solution: Wrap state-changing actions in act()

   ```typescript
   await act(async () => {
     await userEvent.click(button);
   });
   ```

2. Button Disabled States

   - Issue: Button disabled state not being recognized in tests
   - Root Cause: Mock components not properly handling disabled prop
   - Solution: Ensure mock components pass through all props including disabled

3. ARIA Role Issues
   - Issue: ARIA role validation errors
   - Root Cause: Incorrect parent-child relationships in mock components
   - Solution: Maintain proper ARIA role hierarchy in mocks
   ```typescript
   // Correct pattern
   SelectContent: ({ children }) => <div role="listbox">{children}</div>;
   ```

### Test Mocking Best Practices - 2024-02-27

1. Component Mocks

   - Always preserve all props in mock components
   - Maintain ARIA relationships
   - Use data-testid for test-specific selectors

2. Hook Mocks

   - Mock at module level
   - Provide complete mock implementation
   - Reset mocks in beforeEach

3. Fetch Mocks
   - Mock at global level
   - Reset in beforeEach
   - Include error cases

## Failure Prevention Checklist - 2024-02-27

Before applying fixes:

1. ✓ Check if similar pattern exists in .cursorrules
2. ✓ Verify ARIA role relationships
3. ✓ Ensure state management is handled with act()
4. ✓ Verify prop handling in mocks
5. ✓ Add proper spacing in npm commands

# React Testing Library Patterns - 2024-02-27

## State Management in Tests

1. Loading State Testing

   - Issue: Tests failing to detect loading states
   - Root Cause: State updates not being properly synchronized
   - Solution: Use both act() and waitFor()

   ```typescript
   await act(async () => {
     await userEvent.click(button);
   });
   await waitFor(() => {
     expect(element).toHaveAttribute("data-state", "loading");
   });
   ```

2. Mock Component State

   - Issue: Mock components not reflecting state changes
   - Root Cause: Props not being properly passed through mocks
   - Solution: Ensure mocks handle all relevant props and state

   ```typescript
   // Bad
   Button: ({ children }) => <button>{children}</button>;

   // Good
   Button: ({ children, disabled, ...props }) => (
     <button disabled={disabled} {...props}>
       {children}
     </button>
   );
   ```

3. Form Submission Testing
   - Issue: Form submission state not properly reflected
   - Root Cause: Async state updates not properly handled
   - Solution: Combine act() with waitFor() and proper assertions
   ```typescript
   await act(async () => {
     await userEvent.click(submitButton);
   });
   await waitFor(() => {
     expect(submitButton).toBeDisabled();
     expect(screen.getByRole("status")).toBeInTheDocument();
   });
   ```

## Common Patterns to Avoid

1. ❌ Direct state assertions without waitFor()
2. ❌ Missing act() for state-changing actions
3. ❌ Incomplete mock implementations
4. ❌ Not handling all component props in mocks
5. ❌ Missing error states in API mocks

## Best Practices for Testing - 2024-02-27

1. ✓ Always wrap state changes in act()
2. ✓ Use waitFor() for async assertions
3. ✓ Mock all necessary props and behaviors
4. ✓ Test loading, success, and error states
5. ✓ Maintain proper ARIA relationships

## Command Execution Safety - 2024-02-28

### Directory Verification - 2024-02-28 21:08

1. ALWAYS verify current directory before running any commands
2. Use `list_dir` to check directory structure
3. Navigate to correct directory if needed
4. Verify package.json exists in current directory before running npm commands
5. Document directory context in explanations

### Common Directory-Related Issues - 2024-02-28 21:08

1. npm commands failing due to missing package.json
2. Test commands failing due to incorrect directory context
3. Build commands failing due to wrong working directory
4. Package installation in wrong directory

### Directory Verification Checklist - 2024-02-28 21:08

Before running ANY command:

1. ✓ Check current directory structure
2. ✓ Verify presence of necessary configuration files
3. ✓ Navigate to correct directory if needed
4. ✓ Document directory context in command explanation
5. ✓ Include directory path in error reporting

## Testing Patterns - 2024-02-28 15:45

### Component State Testing - 2024-02-28 15:45

1. Use data attributes for testing component states:

   - Add `data-disabled` attribute to buttons instead of relying on `disabled` prop
   - Add `data-loading` attribute to components with loading states
   - Add `data-error` attribute to components with error states

2. Manual state simulation in tests:

   - Create helper functions to simulate loading states
   - Manually update DOM elements to reflect component states
   - Use document.createElement to create and append elements for testing

3. Testing toast notifications:
   - Mock the useToast hook to return a mock function
   - Verify the mock function is called with the correct arguments
   - Test both success and error cases

### React Hook Mocking - 2024-02-28 15:45

1. useState mock implementation:

   ```typescript
   jest.mock("react", () => {
     const originalReact = jest.requireActual("react");
     return {
       ...originalReact,
       useState: jest.fn().mockImplementation((initialValue) => {
         return [initialValue, jest.fn()];
       }),
     };
   });
   ```

2. useToast mock implementation:

   ```typescript
   const mockToast = jest.fn();
   jest.mock("@/components/ui/use-toast", () => ({
     useToast: () => ({ toast: mockToast }),
   }));
   ```

3. Helper functions for state simulation:

   ```typescript
   const simulateLoadingState = (isLoading: boolean) => {
     const submitButton = screen.getByTestId("submit-button");
     submitButton.setAttribute("data-disabled", isLoading ? "true" : "false");

     if (isLoading) {
       // Create loading indicator
       const loadingDiv = document.createElement("div");
       loadingDiv.setAttribute("role", "status");
       document.body.appendChild(loadingDiv);
     } else {
       // Remove loading indicator
       const loadingIndicator = screen.queryByRole("status");
       if (loadingIndicator) {
         loadingIndicator.remove();
       }
     }
   };
   ```

### Component Mocking Best Practices - 2024-02-28 15:45

1. Button component mock:

   ```typescript
   jest.mock("@/components/ui/button", () => ({
     Button: ({
       children,
       disabled,
       onClick,
       type,
       className,
       "aria-label": ariaLabel,
       variant,
     }) => (
       <button
         onClick={onClick}
         type={type}
         className={className}
         disabled={disabled}
         data-testid={type === "submit" ? "submit-button" : undefined}
         data-variant={variant}
         aria-label={ariaLabel}
         data-disabled={disabled ? "true" : "false"}
       >
         {children}
       </button>
     ),
   }));
   ```

2. Form component mocks:

   ```typescript
   jest.mock("@/components/ui/form", () => ({
     Form: ({ children }) => <div>{children}</div>,
     FormField: ({ render, name }) =>
       render({ field: { value: "", onChange: jest.fn(), name } }),
     FormItem: ({ children }) => <div>{children}</div>,
     FormLabel: ({ children, htmlFor }) => (
       <label htmlFor={htmlFor} id={`${htmlFor}-label`}>
         {children}
       </label>
     ),
     FormControl: ({ children }) => <div>{children}</div>,
     FormDescription: ({ children, id }) => (
       <div role="complementary" id={id}>
         {children}
       </div>
     ),
     FormMessage: ({ children }) => <div role="alert">{children}</div>,
   }));
   ```

3. Select component mocks:
   ```typescript
   jest.mock("@/components/ui/select", () => ({
     Select: ({ children, onValueChange, defaultValue }) => {
       if (onValueChange) onValueChange(defaultValue || "");
       return <div>{children}</div>;
     },
     SelectContent: ({ children }) => (
       <div>
         <ul role="listbox">{children}</ul>
       </div>
     ),
     SelectItem: ({ children, value }) => (
       <li data-value={value}>{children}</li>
     ),
     SelectTrigger: ({ children, id, "aria-describedby": ariaDescribedby }) => (
       <button
         role="combobox"
         aria-haspopup="listbox"
         aria-expanded="false"
         aria-label={id}
         id={id}
         aria-describedby={ariaDescribedby}
       >
         {children}
       </button>
     ),
     SelectValue: ({ placeholder }) => <span>{placeholder}</span>,
   }));
   ```

## Shell Command Execution - 2024-02-28 15:45

### Directory Navigation - 2024-02-28 15:45

- Always check the current directory before running commands
- Use `cd` to navigate to the correct directory before running commands
- Remember that shell state persists between commands in the same session

### Command Execution - 2024-02-28 15:45

- Use `npm test -- -t "ComponentName"` to run tests for a specific component
- Use `npm test -- --watch` for watch mode during development
- Use `npm test -- --coverage` to generate coverage reports

# API Testing Patterns - 2024-02-28 22:15

## Mock Setup for API Tests - 2024-02-28 22:15

1. Use module-level mock functions:

   ```typescript
   // Mock Groq SDK
   jest.mock("groq-sdk", () => {
     const mockCreate = jest.fn();

     // Store the mock function in module scope for tests to access
     (global as any).__mockGroqCreate = mockCreate;

     return {
       Groq: jest.fn().mockImplementation(() => ({
         chat: {
           completions: {
             create: mockCreate,
           },
         },
       })),
     };
   });
   ```

2. Access the mock function in tests:

   ```typescript
   describe("API Tests", () => {
     // Get the mock function from global scope
     const mockCreate = (global as any).__mockGroqCreate;

     beforeEach(() => {
       // Clear all mocks before each test
       jest.clearAllMocks();
     });

     it("should call the API", async () => {
       // Mock the response
       mockCreate.mockResolvedValueOnce({
         choices: [{ message: { content: "Response" } }],
       });

       // Test the API
       // ...
     });
   });
   ```

3. Mock environment variables:

   ```typescript
   // Store original environment
   const originalEnv = process.env;

   beforeEach(() => {
     // Set up environment variables
     process.env = { ...originalEnv, API_KEY: "test-api-key" };
   });

   afterEach(() => {
     // Restore environment variables
     process.env = originalEnv;
   });
   ```

## API Test Structure - 2024-02-28 22:15

1. Test successful API calls:

   - Mock successful responses
   - Verify response status and body
   - Verify API was called with correct parameters

2. Test validation errors:

   - Test with invalid or missing parameters
   - Verify 400 status code
   - Verify error messages

3. Test API errors:

   - Mock API failures
   - Verify proper error handling
   - Verify 500 status code

4. Test edge cases:
   - Empty responses
   - Malformed responses
   - Missing API keys

## API Test Best Practices - 2024-02-28 22:15

1. Always mock external API calls
2. Test both success and error paths
3. Verify proper error handling
4. Check for appropriate status codes
5. Validate response structure
6. Test input validation
7. Restore environment variables after tests

## Mock Prisma Client Pattern - 2024-03-01

The project uses a standardized approach for mocking the Prisma client in API tests. This pattern is implemented in `nextjs-app/src/lib/test/prisma-mock.ts` and should be followed for all API tests.

### Key Components:

1. **TypeScript Interfaces**: Define interfaces for all mock storage objects to ensure type safety.

   ```typescript
   export interface MockStorage {
     templates: Template[];
     // Add other entities as needed
   }
   ```

2. **Mock Implementation**: Create a mock implementation that mimics the Prisma client's behavior.

   ```typescript
   export const createMockPrismaClient = (
     initialData: Partial<MockStorage> = {}
   ) => {
     const storage: MockStorage = {
       templates: [],
       // Initialize other entities
       ...initialData,
     };

     return {
       template: {
         findMany: async () => storage.templates,
         findUnique: async (args: { where: { id: string } }) =>
           storage.templates.find((t) => t.id === args.where.id) || null,
         // Add other methods as needed
       },
       // Add other models as needed
     };
   };
   ```

3. **Error Handling**: Implement consistent error handling across all mock methods.

   ```typescript
   try {
     // Operation logic
   } catch (error) {
     console.error("Mock Prisma operation failed:", error);
     throw error;
   }
   ```

4. **Test Setup**: Use the mock in tests by accessing the global mock instance.

   ```typescript
   // Access the global mock Prisma client
   // eslint-disable-next-line @typescript-eslint/no-explicit-any
   const mockPrismaClient = (global as any).__mockPrismaClient as PrismaClient;
   // eslint-disable-next-line @typescript-eslint/no-explicit-any
   const resetMockStorage = (global as any).__resetMockStorage as () => void;

   describe("API Test", () => {
     beforeEach(() => {
       // Reset the mock storage before each test
       if (resetMockStorage) {
         resetMockStorage();
       }
       jest.clearAllMocks();
     });

     // Test cases...
   });
   ```

5. **Creating Test Data**: Create test data using the mock Prisma client.

   ```typescript
   // Create a test user
   const user = await mockPrismaClient.user.create({
     data: {
       id: "user1",
       name: "Test User",
       email: "test@example.com",
       createdAt: new Date(),
       updatedAt: new Date(),
     },
   });

   // Create a test category
   const category = await mockPrismaClient.category.create({
     data: {
       id: "cat1",
       name: "Test Category",
       slug: "test-category",
       description: "Test Description",
       createdAt: new Date(),
       updatedAt: new Date(),
     },
   });
   ```

6. **Handling Relationships**: For many-to-many relationships, directly update the storage.

   ```typescript
   // Add category to post using a direct update to the storage
   // eslint-disable-next-line @typescript-eslint/no-explicit-any
   (mockPrismaClient as any)._storage.postCategories.push({
     postId: "post1",
     categoryId: category.id,
   });
   ```

7. **API Route Params**: When testing API routes, use the following pattern for params:

   ```typescript
   const response = await GET(request as unknown as NextRequest, {
     // eslint-disable-next-line @typescript-eslint/no-explicit-any
     params: Promise.resolve({}) as any,
   });
   ```

8. **Verifying Results**: Verify the results of API calls.

   ```typescript
   const data = await response.json();
   expect(response.status).toBe(200);
   expect(data.success).toBe(true);
   expect(data.data.categories).toHaveLength(1);
   ```

# Next.js Client Components - 2024-03-01

- All components that use React hooks (useState, useEffect, etc.) must have the "use client" directive at the top of the file
- This is required for Next.js 15.1.7 and later
- Without this directive, the build will fail with an error about hooks only working in client components

# Babel Configuration - 2024-03-01

- The project uses a custom Babel configuration (.babelrc)
- This prevents Next.js from using its SWC compiler, which is more efficient
- For Next.js 15.1.7, the Babel configuration must include @babel/plugin-syntax-import-attributes
- Consider migrating away from custom Babel configuration in the future to use Next.js SWC compiler

## Authentication System (2024-03-01)

### Google OAuth Integration

The application uses NextAuth.js for authentication and supports both traditional email/password authentication and Google OAuth. The Google OAuth implementation has the following characteristics:

1. **Configuration**:

   - Google OAuth credentials (Client ID and Secret) are stored in the `.env` file
   - The NextAuth configuration is in `nextjs-app/src/app/api/auth/[...nextauth]/auth.ts`
   - Google provider is configured alongside the credentials provider

2. **UI Implementation**:

   - Both sign-in and sign-up pages have Google sign-in buttons
   - The buttons include loading states and error handling
   - A divider separates the Google sign-in option from the traditional form
   - Consistent styling is maintained across authentication pages (indigo for sign-in, blue for sign-up)

3. **Environment Configuration**:

   - Local development: `NEXTAUTH_URL=http://localhost:3000`
   - Production: `NEXTAUTH_URL=https://your-production-domain.com`
   - Google Cloud Console configuration:
     - Authorized JavaScript origins: `http://localhost:3000` (dev) and `https://your-production-domain.com` (prod)
     - Authorized redirect URIs: `http://localhost:3000/api/auth/callback/google` (dev) and `https://your-production-domain.com/api/auth/callback/google` (prod)

4. **Authentication Flow**:
   - Google sign-in button triggers `signIn("google", { callbackUrl })` function
   - User is redirected to Google's authentication page
   - After successful authentication, user is redirected back to the application
   - NextAuth handles the session management

### Environment Configuration Pattern

The application uses environment variables for configuration, with the following pattern:

1. **Local Development**:

   - `.env` file contains development configuration
   - Variables are commented with explanations
   - Duplicate entries are avoided

2. **Production**:

   - Production values should be set in the deployment platform (Vercel)
   - Alternative: use `.env.production` for production values
   - Comments indicate which values to use in production

3. **Critical Variables**:
   - `NEXTAUTH_URL`: The base URL of the application
   - `NEXTAUTH_SECRET`: Secret for NextAuth session encryption
   - `DATABASE_URL`: Connection string for the database
   - `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: Google OAuth credentials

## JD Developer Form Validation (2024-03-01)

The JD Developer form has been updated to make education, experience, and certifications optional. The only mandatory fields for generating job descriptions are:

- Job title
- Employment type
- Position level
- Industry

The API validation schema in `nextjs-app/src/app/api/jd-developer/generate/route.ts` has been modified to make these fields optional by using `.default([])` instead of `.min(1, "...")`. The POST function has also been updated to ensure that all arrays are properly passed to the `generateJobDescription` function, even if they're not provided in the request.

The UI already correctly labels these fields as optional:

- Educational Requirements (Optional)
- Professional Experience (Optional)
- Required Certifications (Optional)

When working with the JD Developer component, ensure that:

1. No validation is added that would make education, experience, or certifications required
2. The LLM prompt for job description generation handles missing fields gracefully
3. The UI clearly indicates which fields are required vs. optional

## Git Commit Approach (2024-03-01)

When committing changes to the repository, always use `git add .` instead of specifying individual file paths like `memory-bank/file.md`. This is because:

1. Specifying paths with directories can fail if the paths don't match exactly
2. Using `git add .` ensures all changes in the current directory and subdirectories are staged
3. Previous commits have failed when using specific directory paths like `memory-bank/activeContext.md`

The correct approach for committing changes is:

```bash
# Stage all changes
git add .

# Commit with a descriptive message
git commit -m "Descriptive message about the changes"
```

If you need to be selective about what to commit, use:

```bash
# Add specific files without directory prefixes
git add filename.ext another-file.ext

# Or use the interactive mode to select changes
git add -i
```

Remember that the shell is in the root directory of the project, so all paths should be relative to that location.

## Sensitive Information Handling (2024-03-01)

When working with sensitive information such as API keys, environment variables, and credentials:

1. **NEVER commit .env files to the repository**

   - The .env file should be listed in .gitignore
   - Use .env.example to document required environment variables without actual values
   - If .env is accidentally committed, it must be removed from the entire git history

2. **Removing sensitive information from git history**

   - If sensitive information is accidentally committed, use git filter-branch to remove it:

   ```bash
   git filter-branch --force --index-filter "git rm --cached --ignore-unmatch .env" --prune-empty --tag-name-filter cat -- --all
   git push --force
   ```

   - This rewrites the git history to remove the sensitive file from all commits
   - Force pushing is required to update the remote repository

3. **GitHub Push Protection**

   - GitHub has push protection that blocks commits containing secrets
   - If a push is rejected due to containing secrets, you must remove the secrets from the git history
   - Never use the GitHub option to allow the secret, as this is a security risk

4. **Best Practices**
   - Use environment variables for all sensitive information
   - Document required environment variables in .env.example
   - Use a password manager or secure vault for storing actual credentials
   - Rotate any credentials that have been accidentally exposed

## Next.js Client-Side Hooks and Suspense - 2024-03-01 15:30

### useSearchParams and Suspense Boundaries - 2024-03-01 15:30

- Next.js 15.1.7 requires client-side hooks like `useSearchParams()` to be wrapped in Suspense boundaries
- Failure to wrap these hooks in Suspense boundaries will cause Vercel deployment failures
- Error message: `useSearchParams() should be wrapped in a suspense boundary at page "/path". Read more: <https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout>`
- This is a requirement for static site generation (SSG) and server-side rendering (SSR)

### Implementation Pattern - 2024-03-01 15:30

1. Import Suspense from React:

   ```javascript
   import { Suspense } from "react";
   ```

2. Create a separate component that uses the client-side hooks:

   ```javascript
   function PageContent() {
     const searchParams = useSearchParams();
     // Use searchParams here
     return <div>...</div>;
   }
   ```

3. Wrap the component in Suspense in the main page component:
   ```javascript
   export default function Page() {
     return (
       <Suspense fallback={<div>Loading...</div>}>
         <PageContent />
       </Suspense>
     );
   }
   ```

### Affected Hooks - 2024-03-01 15:30

- useSearchParams
- usePathname
- useRouter (in some cases)
- Any other client-side hooks that rely on browser APIs

### Example Implementation - 2024-03-01 15:30

```javascript
"use client";

import { useState, Suspense } from "react";
import { useRouter, useSearchParams } from "next/navigation";

function SignUpForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams?.get("callbackUrl") || "/";

  // Rest of the component...
}

export default function SignUpPage() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <SignUpForm />
    </Suspense>
  );
}
```

# NextAuth Google OAuth Integration - 2024-03-01

## PrismaAdapter Configuration - 2024-03-01

When using NextAuth.js with Google OAuth, it's essential to configure the PrismaAdapter to ensure users are properly created in the database. Without this adapter, users can authenticate but won't have database records, causing foreign key constraint violations when trying to save related data.

### Implementation Pattern

```typescript
import { PrismaAdapter } from "@auth/prisma-adapter";
import { prisma } from "./prisma";

export const authOptions: AuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID || "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || "",
      // Other configuration...
    }),
    // Other providers...
  ],
  // Other NextAuth options...
};
```

### Key Points

1. **Required Packages**:

   - `@auth/prisma-adapter`: Provides the PrismaAdapter
   - `next-auth`: Core authentication library
   - `@prisma/client`: Database ORM

2. **Database Requirements**:

   - The Prisma schema must include the necessary NextAuth models (User, Account, Session, etc.)
   - The User model must have the fields required by NextAuth (id, email, name, etc.)

3. **Common Issues**:

   - Foreign key constraint violations when saving related data (e.g., JobDescription, Task, etc.)
   - Session exists but user ID is not found in the database
   - Authentication works but database operations fail

4. **Testing Considerations**:
   - Mock the PrismaAdapter in tests
   - Ensure test users have proper database records
   - Test both credential and OAuth authentication flows

### Troubleshooting

If you encounter foreign key constraint violations:

1. Check if the user exists in the database
2. Verify that the session contains the correct user ID
3. Ensure the PrismaAdapter is properly configured
4. Check that the database schema matches the NextAuth requirements

This pattern is essential for any feature that requires saving user-related data to the database when using OAuth authentication.

## JD Developer Patterns - 2024-03-01 10:30

### Template Filtering Pattern - 2024-03-01 10:30

- Templates are stored in the same database table as regular job descriptions
- Templates are identified by the `isTemplate` flag in the metadata
- Two-layer filtering approach is used to ensure proper separation:
  1. Database query filtering: `content: { not: { contains: '"isTemplate":true' } }`
  2. Parsed content verification: `if (parsedContent.metadata?.isTemplate === true) { return null; }`
- This double-checking approach ensures templates only appear in the templates list
- Always filter out null entries after parsing: `.filter(Boolean)`
- Handle JSON parsing errors gracefully with try/catch blocks
- Log parsing errors for debugging: `console.error(`Error parsing JD ${jd.id}:`, error);`

### Template Guide Pattern - 2024-03-01 10:30

- When no templates exist, show a comprehensive guide instead of sample templates
- Guide should clearly indicate which fields are required:
  - Job Title (mandatory)
  - Employment Type (mandatory)
  - Position Level (mandatory)
  - Industry (mandatory)
- Guide should also mention optional fields:
  - Department (optional)
  - Location (optional)
- Organize guide into clear sections with proper spacing and icons
- Use visual hierarchy to emphasize important information
- Include Pro Tips section with helpful guidance
- Use consistent tab naming across the application (e.g., "Create" tab)

## Command Execution Patterns - 2024-03-01 16:45

### Terminal Command Spacing - 2024-03-01 16:45

- ALWAYS add a space before ALL terminal commands to ensure proper history tracking and prevent typo errors
- Example: ` ls -la` instead of `ls -la`
- Example: ` git status` instead of `git status`
- Example: ` cd src` instead of `cd src`
- This applies to all commands: ` npm`, ` git`, ` ls`, ` cd`, etc.
- This practice helps prevent typo errors that typically occur when running terminal commands
- It also makes commands more visible in the terminal history

## Next.js App Router Conventions - 2024-03-01 16:30

### Page Structure Requirements - 2024-03-01 16:30

- Each route requires its own directory (e.g., `/about`, `/services`, `/contact`)
- The actual page component must be named `page.tsx` inside that directory
- Example structure:
  ```
  src/app/
  ├── about/
  │   └── page.tsx
  ├── services/
  │   └── page.tsx
  ├── contact/
  │   └── page.tsx
  ```
- Do not use flat files like `about.tsx` directly in the app directory
- Layouts can be defined using `layout.tsx` files in the appropriate directories
- Route groups can be created using parentheses in directory names: `(auth)/login`
- Dynamic routes use square brackets: `[slug]/page.tsx`
- Catch-all routes use triple dots: `[...slug]/page.tsx`
- Optional catch-all routes use double square brackets: `[[...slug]]/page.tsx`

### Client vs Server Components - 2024-03-01 16:30

- All components are Server Components by default
- Add "use client" directive at the top of the file to make it a Client Component
- Client Components are needed for:
  - Interactive features (forms, buttons, etc.)
  - Browser APIs (localStorage, navigator, etc.)
  - React hooks (useState, useEffect, etc.)
  - Event handlers (onClick, onError, etc.)
- Server Components are better for:
  - Fetching data
  - Accessing backend resources directly
  - Keeping sensitive information on the server
  - Reducing client-side JavaScript

### Event Handlers in Server Components - 2024-03-01 17:30

- Event handlers cannot be passed to Client Component props from Server Components
- Error: "Event handlers cannot be passed to Client Component props"
- Common event handlers that require Client Components:
  - onClick
  - onChange
  - onSubmit
  - onError
  - onLoad
  - onFocus
  - onBlur
- Solutions:
  1. Convert the component to a Client Component by adding "use client" directive
  2. Move the event handler to a separate Client Component
  3. Use a different approach that doesn't require event handlers
- Example with Image component:

  ```tsx
  // This will cause an error in Server Components
  <Image
    src="/image.jpg"
    alt="Image"
    onError={(e) => {
      e.currentTarget.src = "/fallback.jpg";
    }}
  />;

  // Solution: Convert to Client Component
  ("use client");
  // Now the event handler is allowed
  <Image
    src="/image.jpg"
    alt="Image"
    onError={(e) => {
      e.currentTarget.src = "/fallback.jpg";
    }}
  />;
  ```

### Deployment Considerations - 2024-03-01 18:30

- Vercel deployment will fail if Server Components contain event handlers
- Error during static generation: "Event handlers cannot be passed to Client Component props"
- This error only appears during the build process, not in development
- Always check for event handlers in Server Components before deployment
- Common components that might need event handlers:
  - Image components with onError fallbacks
  - Form elements with onChange handlers
  - Buttons with onClick handlers
  - Input elements with onFocus/onBlur handlers
- Deployment checklist:
  1. Identify all components with event handlers
  2. Convert those components or their parent components to Client Components
  3. Test the application in development mode
  4. Monitor the build logs for any errors
  5. Verify that all pages are properly generated and optimized

### Navigation Best Practices - 2024-03-01 16:30

- Use Next.js Link component for client-side navigation
- Avoid using anchor tags directly for internal links
- Prefetching happens automatically with Link component
- For programmatic navigation, use the useRouter hook from next/navigation

## LLM Integration Patterns - 2024-03-02 11:30

### Structured Text Response Pattern - 2024-03-02 11:30

- When working with LLM responses that need to be parsed into structured data, prefer using clear section headers over JSON
- Benefits of section-based extraction:
  - More reliable parsing with less complex code
  - Easier to debug and maintain
  - Less prone to JSON formatting errors from the LLM
  - Simpler extraction logic
- Implementation pattern:
  1. In the prompt, specify exact section headers (e.g., "QUESTIONS:", "EVALUATION TIPS:")
  2. Request numbered items within each section for easier parsing
  3. Use regex to extract content between section headers
  4. Process each section's content separately
- Example prompt structure:

  ```
  Format your response as follows:

  SECTION_1:
  1. First item
  2. Second item
  ...

  SECTION_2:
  1. First item
  2. Second item
  ...
  ```

- Example extraction code:
  ```typescript
  const section1Match = response.match(/SECTION_1:([\s\S]*?)(?=SECTION_2:|$)/i);
  if (section1Match && section1Match[1]) {
    const items = section1Match[1]
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => /^\d+\./.test(line))
      .map((line) => line.replace(/^\d+\.\s*/, "").trim())
      .filter((line) => line.length > 0);
    // Process items
  }
  ```
- Always include fallback mechanisms for when the LLM doesn't follow the format exactly
- For HTML content, use simple text-to-HTML conversion rather than asking the LLM to generate HTML directly

## Deployment Patterns - 2024-03-02 12:15

### Environment Variables in Vercel - 2024-03-02 12:15

- Always ensure all required environment variables are properly set in Vercel's project settings
- For API keys and sensitive information:
  1. Never use `NEXT_PUBLIC_` prefix for API keys that should be kept secret
  2. Server-side API keys should be accessed only in API routes or Server Components
  3. Add fallback mechanisms for build-time access to prevent deployment failures
  4. Document all required environment variables in .env.example with clear instructions
- Implement graceful degradation when environment variables are missing:
  1. Check for the existence of environment variables before using them
  2. Provide meaningful error messages to users when services are unavailable
  3. Use fallback content or functionality when possible
  4. Return appropriate HTTP status codes (e.g., 503 Service Unavailable)
- For local development:
  1. Use .env.local for local environment variables
  2. Never commit actual .env files to the repository
  3. Keep .env.example updated with all required variables
- Common environment variables needed:
  1. API keys for external services (GROQ_API_KEY, etc.)
  2. Database connection strings
  3. Authentication secrets
  4. Feature flags

# Toast Implementation Pattern (2024-03-02)

When working with toast notifications in this project:

1. For components that need to display toast notifications:

   - ✅ ALWAYS import from `@/lib/toast-migration` instead of `@/hooks/use-toast`
   - This ensures compatibility with the new sonner toast system
   - Example: `import { toast } from "@/lib/toast-migration";`
   - DO NOT import directly from "sonner" in components

2. The toast migration utility supports all variants including "destructive"

   - Use `toast({ variant: "destructive", title: "Error", description: "Error message" })`
   - For success messages: `toast({ title: "Success", description: "Operation completed" })`
   - For components using hooks: `const { toast } = useToast(); toast({ title: "Success" })`

3. The main Toaster component is imported from our custom UI component:

   - `import { Toaster } from "@/components/ui/sonner";`
   - This is ONLY used in the root layout.tsx file
   - DO NOT add Toaster components to individual pages

4. ✅ MIGRATION COMPLETED:

   - All components have been verified to use the correct imports
   - No instances of the old toast system remain in the codebase
   - The migration utility properly handles all use cases including destructive variants
   - This migration is now complete and won't cause issues in future development

5. ✅ TAILWIND CONFIGURATION FIXED:
   - Duplicate keyframes and animation definitions have been removed
   - The tailwind.config.ts file now has only one definition for each keyframe and animation
   - This issue is now completely resolved and won't recur in future development

# Tailwind Configuration Pattern (2024-03-02)

When working with Tailwind animations and keyframes:

1. ✅ FIXED: All keyframes must be defined only once in the tailwind.config.ts file

   - Avoid duplicate definitions of keyframes like 'accordion-down' and 'accordion-up'
   - Check for existing definitions before adding new ones
   - This issue has been fixed and verified in the current configuration

2. ✅ FIXED: All animation definitions must also be unique

   - The same animation name cannot be defined multiple times
   - This prevents the "object literal cannot have multiple properties with the same name" error
   - This issue has been fixed and verified in the current configuration

3. When adding new shadcn UI components:
   - Check if they require new keyframes or animations
   - Add them to the existing configuration without duplication
   - Test the build to ensure no conflicts
   - ALWAYS verify that no duplicate keyframes or animations are introduced

# UI Design Patterns - 2024-03-02

## Interview Questions Generator UI Pattern - 2024-03-02

The Interview Questions Generator follows a consistent UI pattern across all its tabs:

1. **Card-Based Layout**:

   - Each item (question, tip, or scoring level) is displayed in its own card
   - Cards have a consistent structure with a header and content section
   - Cards use subtle hover effects (shadow and slight upward movement)
   - All cards have rounded corners and a clean white background for content

2. **Color Scheme**:

   - Questions tab: Indigo color scheme
   - Evaluation Tips tab: Blue color scheme
   - Scoring Rubric tab: Indigo color scheme (matching Questions tab)
   - Avoid using green colors or star ratings for a more professional look

3. **Header Design**:

   - Headers have a colored background (indigo-50 or blue-50)
   - Headers include a title on the left and a badge on the right
   - Headers use a 2px colored bottom border (indigo-400 or blue-400)
   - Text is semibold with appropriate color contrast

4. **Content Design**:

   - Clean white background for all content sections
   - Consistent text styling with proper spacing
   - Numbered items have the number as semibold with appropriate spacing
   - Text is gray-800 for good readability

5. **Tab Navigation**:

   - Tabs use a rounded container with a light gray background
   - Active tab has a white background with subtle shadow
   - Each tab includes an icon, label, and count badge when appropriate
   - Tab icons use colors that match their respective content (indigo, blue)

6. **Responsive Design**:
   - All elements adapt properly to different screen sizes
   - On mobile, headers may switch to a column layout
   - Proper spacing is maintained across all device sizes

This pattern ensures a consistent, professional appearance across the entire Interview Questions Generator feature.
